---
title: "Fall 2022 DANL 200 Final Exam 3"
author: "Byeong-Hak Choe"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    code-tools: true
execute:
  echo: true
  eval: true
  message: false
  warning: false
---
```{r, include=F}
library(tidyverse)
library(skimr)
library(lubridate)
library(stargazer)
library(broom)
library(hrbrthemes)
theme_set(theme_ipsum())
```


# Load R packages
```{r, eval=F}
#| code-fold: false

library(tidyverse)
library(skimr)
library(lubridate)
library(stargazer)
library(broom)
```


# Question 1

The following is the data.frame for Question 1.

```{r}
#| code-fold: false
teen_emp <- read_csv("https://bcdanl.github.io/data/teen_emp.csv")
```

- The data.frame, teen_emp, contains teen employment in 500 counties in the U.S. from 2004 to 2007. 

## Variable description
- `year`: year of the observation
- `id_county`: a unique identifier (FIPS) for a particular county
- `pop`: population for a county 
- `emp`: teen workers in a county at the end of that year
- `yr_raise`: a year that a state where a county is located raised its minimum wage at the beginning of the year, 
  - `NA` for a county if a minimum wage is equal to the federal minimum wage over the entire period.

## Q1a.
- Download the ZIP file that contains the CSV file, `county_population_2004_2007.csv`.

- The CSV file, `county_population_2004_2007.csv`, has the following three variables:
  - `year`: year
  - `fips`: a unique identifier (FIPS) for a US county
  - `pop`: population

- Read the CSV file, `county_population_2004_2007.csv`, as data.frame with the name, `df_pop`, using its absolute pathname and `read_csv()`.

```{r}
df_pop <- read_csv("/Users/byeong-hakchoe/Google Drive/suny-geneseo/teaching-materials/lecture-data/county_population_2004_2007.csv")
```

<br>

## Q1b.
- Remove the variable `pop` from the data.frame `teen_emp`.

- Then add the variable `pop` in the data.frame, `df_pop`, to the data.frame, `teen_emp`, by joining `teen_emp` and `df_pop`.

- The resulting data.frame must contain 
  - (1) all the observations in `teen_emp`, while not having any missing values in variable, `emp`; and
  - (2) only the following variables with the following order: `id_county`, `year`, `pop`,  `emp`, and `yr_raise`.


```{r}
teen_emp <- teen_emp %>% 
  select(-pop)

teen_emp <- teen_emp %>% 
  left_join(df_pop, by = c("id_county" = "fips", "year"))

teen_emp <- teen_emp %>% 
  select(`id_county`, `year`, `pop`,  `emp`,  `yr_raise`)
```

<br>

## Q1c.
Add the variables, `name` and `state`, in the data.frame, `county_name`, to the data.frame, `teen_emp`, by joining the two data.frames, `teen_emp` and `county_name`.

```{r}
#| code-fold: false
county_name <- read_csv(
  "https://bcdanl.github.io/data/county_name.csv"
)
```
- Variables in `county_name`
  - `id`: a unique identifier (FIPS) for a US county
  - `name`: County Name
  - `state`: County Name

- The resulting data.frame must contain 
  - (1) all the observations in `teen_emp`, while not having any missing values in variable, `emp`; and
  - (2) only the following variables with the following order: `id_county`, `name`,  `state`, `year`, `pop`,  `emp`, and `yr_raise`.

```{r}
teen_emp <- teen_emp %>% 
  left_join(county_name, by = c("id_county" = "id")) %>% 
  select(`id_county`, `name`,  `state`, `year`, `pop`,  `emp`, `yr_raise`)

```


<br>

## Q1d.
- Add the following two variables---
  - (1) `emp_perc`, the percentage of people that are teen workers in a county
  - (2) `raise`, `TRUE` if there was a raise in minimum wage in a county during the period of time; `FALSE` otherwise
---to the data.frame, `teen_emp`.

```{r}
q1d <- teen_emp %>% 
  mutate(emp_perc = 100 * emp / pop,
         raise = ifelse(!is.na(yr_raise), T, F))
```

<br>

## Q1e.
Report mean, median, minimum, maximum, standard deviation of variable, `emp_perc`, for each `state`.

```{r}
q1e <- q1d %>% 
  group_by(state) %>% 
  skim(emp_perc)
```

<br>

## Q1f.
In the resulting data.frame from Q1d, or `teen_emp`, remove observations for which values of `yr_raise` is missing.

```{r}
q1f <- filter( q1d, !is.na(yr_raise) )
```

<br>

## Q1g.
Provide both (1) ggplot and (2) a simple comment to describe the yearly trend of the distribution of `emp_perc` before and after `yr_raise`.

```{r}
q1g <- q1f %>% 
  mutate(yr = year - yr_raise)

ggplot(q1g) +
  geom_boxplot(aes(x = factor(yr), y = emp_perc))

ggplot(q1g) +
  geom_density(aes(y = emp_perc)) +
  facet_grid(.~ factor(yr))
```

<br>

## Q1h.
Provide both (1) ggplot and (2) a simple comment to describe the yearly trend of the distribution of `emp_perc` for counties that did not raise their minimum wages during the time period.

```{r}
q1h <- filter(q1d, 
              raise == F)

ggplot(q1h) +
  geom_boxplot(aes(x = factor(year), y = emp_perc))
```

<br><br>

# Question 2

- The following is the description for Question 2:

- TripAdvisor is an online travel research company that empowers people around the world to plan and enjoy the ideal trip. 

- TripAdvisor wanted to know whether promoting membership on their platform could drive engagement and bookings. 

- To do so, TripAdvisor had just run an experiment to explore user retention by offering a random subset of customers an easier sign-up process for membership.


- The following is the data.frame for Question 2:


```{r}
#| code-fold: false
tripadvisor <- read_csv("https://bcdanl.github.io/data/tripadvisor_cleaned.csv")
```

## Variable description
- `id`: a unique identifier for a user.
- `time`:	
  - `PRE` if `time` is before the experiment; 
  - `POST` if `time` is in the 28 days after the experiment.
- `days_visited`:	Number of days a user visited the TripAdvisor website.
- `easier_signup`: `TRUE` if a user was exposed to the easier signup process (e.g., one-click signup) during the experiment; FALSE otherwise.
- `became_member`: `TRUE` if a user became a member during the experiment period; `FALSE` otherwise.
- `locale_en_US`: `TRUE` if a user accessed the website from the US; `FALSE` otherwise.
- `os_type`:	Windows, Mac, or Others
- `revenue_pre`:  Amount of dollars a user spent on the website before the experiment


- In the data.frame, `tripadvisor`, for each `id` value, there are two types of observations---one with `time == "PRE"` and the other with `time == "POST"`.


<br>

## Q2a.
Using the given data.frame, `tripadvisor`, create the data.frame, tripadvisor, for which
  - (1) `time` is a factor-type variable of `time` with a reference level, `"PRE"`.
  - (2) `os_type` is a factor-type variable of `os_type` with a reference level, `"Windows"`.
  
```{r}
q2a <- tripadvisor %>% 
  mutate(time = factor(time, levels = c("PRE", "POST")),
         os_type = factor(os_type, levels = c("Windows", "Mac", "Others") ) )
```

<br>

## Q2b.
Provide both (1) ggplot and (2) a simple comment to describe how the relationship between `time` and `days_visited` varies by `easier_signup` and `became_member`.

```{r}
ggplot(q2a) +
  geom_boxplot(aes(y = days_visited, 
                   x = time,
                   fill = time) ) +
  facet_grid(easier_signup ~ became_member)
```
Comments are not provided here.

<br>

## Q2c.
Provide both (1) ggplot and (2) a simple comment to describe the distribution of `days_visited` varies by `os_type`.

```{r}
ggplot(q2a) +
  geom_density(aes(x = days_visited,
                   color = os_type) ) 
```

Comments are not provided here.

<br>

## Q2d.
Provide both (1) ggplot and (2) a simple comment to describe how the relationship between `revenue_pre` and `days_visited` varies by `time` conditioning that `revenue_pre` is less than or equal to its third quartile level.

```{r}
skim(q2a$revenue_pre) # to see the third quartile level

ggplot(data = filter(q2a, revenue_pre <=7.39),
       aes(y = revenue_pre,
           x = factor(days_visited))) +
  geom_boxplot() +
  facet_grid(time ~.)
```

<br>

## Q2e.
- Randomly split the data.frame, `tripadvisor`, into training and testing data.frames.
- Approximately 70% of observations in the data.frame, tripadvisor, must go to the training data.frame. 
- The rest observations in the the data.frame, tripadvisor, must go to the testing data.frame.


-Additionally, 
  - (1) the number of observations for each `id` must be 2 in both training and testing data.frames.
  - (2) the distribution of `easier_signup` and the distribution of `became_member` are approximately the same between training and testing data.frames.

```{r}
df_1 <- filter(q2a, easier_signup == 0 & became_member == 0, time == "PRE")
df_2 <- filter(q2a, easier_signup == 0 & became_member == 1, time == "PRE")
df_3 <- filter(q2a, easier_signup == 1 & became_member == 0, time == "PRE")
df_4 <- filter(q2a, easier_signup == 1 & became_member == 1, time == "PRE")

df_1p <- filter(q2a, easier_signup == 0 & became_member == 0, time == "POST")
df_2p <- filter(q2a, easier_signup == 0 & became_member == 1, time == "POST")
df_3p <- filter(q2a, easier_signup == 1 & became_member == 0, time == "POST")
df_4p <- filter(q2a, easier_signup == 1 & became_member == 1, time == "POST")

gp_1 <- nrow( filter(q2a, easier_signup == 0 & became_member == 0, time == "PRE") )
gp_2 <- nrow( filter(q2a, easier_signup == 0 & became_member == 1, time == "PRE") )
gp_3 <- nrow( filter(q2a, easier_signup == 1 & became_member == 0, time == "PRE") )
gp_4 <- nrow( filter(q2a, easier_signup == 1 & became_member == 1, time == "PRE") )

gp_1 <- runif( gp_1 )
gp_2 <- runif( gp_2 )
gp_3 <- runif( gp_3 )
gp_4 <- runif( gp_4 )


train_1 <- filter(df_1, gp_1 >= .3)
test_1 <- filter(df_1, gp_1 < .3)
train_2 <- filter(df_2, gp_2 >= .3)
test_2 <- filter(df_2, gp_2 < .3)
train_3 <- filter(df_3, gp_3 >= .3)
test_3 <- filter(df_3, gp_3 < .3)
train_4 <- filter(df_4, gp_4 >= .3)
test_4 <- filter(df_4, gp_4 < .3)

train_1p <- filter(df_1p, gp_1 >= .3)
test_1p <- filter(df_1p, gp_1 < .3)
train_2p <- filter(df_2p, gp_2 >= .3)
test_2p <- filter(df_2p, gp_2 < .3)
train_3p <- filter(df_3p, gp_3 >= .3)
test_3p <- filter(df_3p, gp_3 < .3)
train_4p <- filter(df_4p, gp_4 >= .3)
test_4p <- filter(df_4p, gp_4 < .3)

dtrain <- rbind(train_1, train_2, train_3, train_4,
                train_1p, train_2p, train_3p, train_4p)
dtest <- rbind(test_1, test_2, test_3, test_4,
               test_1p, test_2p, test_3p, test_4p)

dtrain <- dtrain %>% 
  arrange(id, time)
dtest <- dtest %>% 
  arrange(id, time)


# prop.table(table(dtrain$became_member))
# prop.table(table(dtest$became_member))
# prop.table(table(dtrain$easier_signup))
# prop.table(table(dtest$easier_signup))
```


<br>

## Q2f.
Consider the following formulas for linear regression:

```{r}
#| code-fold: false
formula_1 <- days_visited ~ time * easier_signup  +
  os_type + locale_en_US + revenue_pre

formula_2 <- days_visited ~ time * easier_signup * became_member + 
  os_type + locale_en_US + revenue_pre
```

- Train the linear regression model with the above formula.

- If you could not properly split the data.frame into the training and testing data.frames in Q2e, use the data.frame, pension_tax, as the training data.frame.

- Report the summary of the linear regression result.

```{r}
model_1 <- lm(data = dtrain,
              formula_1)
model_2 <- lm(data = dtrain,
              formula_2)
```

```{r, eval = F}
stargazer::stargazer(model_1, model_2,
                     type = 'text')
```

```{r, echo = F, results='asis'}
stargazer::stargazer(model_1, model_2,
                     type='html')
```

<br>

## Q2g.
- Visualize the confidence intervals of all the beta estimates except for the variables `(Intercept)` from the model with `formula_2`.

- What does it mean that a confidence interval of a beta estimate contains a zero level of its beta estimate?

```{r}
sum_model_2 <- tidy(model_2)

ggplot(filter(sum_model_2,
              term != "(Intercept)")) +
  geom_pointrange( aes(x = term, 
                       y = estimate,
                       ymin = estimate - 2*std.error,
                       ymax = estimate + 2*std.error ) ) +
  coord_flip()

```


- If `estimate == 0` belongs to a confidence interval of the beta estimate, the beta estimate may not be statistically different from zero, and there is insufficient evidence to conclude that there is a non-zero relationship between the explanatory variable and the outcome variable.

<br>

## Q2h. 
- Interpret the estimated beta coefficients for the following variables---

  - (1) `os_typeMac`
  - (2) `revenue_pre`
  - (3) `timePOST`
  - (4) `timePOST:easier_signup`
  - (5) `timePOST:became_member`

---from the model with `formula_2` in Q2f.

```{r}
b2 <- coef(model_2)
```

Interpretation of the beta estimates are not provided here.

<br>

## Q2i. 
- Provide (1) the interpretation of the beta estimate that addresses the following question---How did introducing easier signup process affect the level of engagement in the website?---and (2) any intuitive explanations on it.

- Interpretation of the beta estimates are not provided here.

<br><br>

# Question 3

The following is the data.frame for Question 3:

```{r}
#| code-fold: false
netflix <- read_csv(
  "https://bcdanl.github.io/data//netflix_cleaned.csv")
```

## Variable description
- `id`: unique identifier for each show
- `title`: title
- `description`: description
- `director`: directors
- `genre`: genres 
  - Each content can belong to multiple genres. 
  - They are seperated by commas. 
  - The maximum number of genres a show can belong to is 3.
- `cast`: cast (seperated by commas)
- `production_country`: production countries 
  - Each content could be produced in multiple countries. 
  - They are separated by commas. 
  - The maximum number of countries in which a show was produced is 8.
- `release_date`: release date (year in which it was released)
- `date_added`: date the show was added to Netflix
  - e.g., the format of the value is character with
                    `MONTH DAY, YEAR`
- `rating`: rating
- `duration`: duration (in min for movies and number of seasons (e.g., 2 Seasons) for shows)

<br>

## Q3a.
- In the data.frame, netflix, separate the variable `imdb_score` into the two numeric variables, `imdb` and `imdb_max`, for which
  - (1) `imdb` is a value of `imdb_score` before `/`;
  - (2) `imdb_max` is a value of `imdb_score` after `/`.

- For example, if `imdb_score == 6.6/10`, `imdb == 6.6` and `imdb_max == 10`.


- In the data.frame, `netflix`, separate the variable `genre` into the three variables, `genre_1`, `genre_2`, and `genre_3`, for which a value of each variable, `genre_1`, `genre_2` and `genre_3`  is one single genre.


- In the data.frame, netflix, separate the variable `production_country` into the eight variables, `country_1`, `country_2`, `country_3`, `country_4`, `country_5`, `country_6`, `country_7`, and `country_8`, in which a value of each variable `country_1`, `country_2`, `country_3`, `country_4`, `country_5`, `country_6`, `country_7`, and `country_8` is one single country.


```{r}
q3a <- netflix %>% 
  separate(imdb_score, into = c("imdb", "imdb_max"),
           sep = "/", convert = T) %>% 
  separate(genre, into = c("genre_1", "genre_2", "genre_3"),
           sep = ",", convert = T)  %>% 
  separate(production_country, into = c("country_1", "country_2", 
                                        "country_3", "country_4", 
                                        "country_5", "country_6", 
                                        "country_7", "country_8"),
           sep = ",", convert = T) 

q3a_chk <- q3a %>% 
  filter(!is.na(country_8))
```

<br>

## Q3b.
- Create the data.frame with the following two variables:
  - `country`: country that produced a show
  - `n_shows`: number of shows produced in a particular country.

- Then, find the top 10 countries in terms of the 10 largest values of `n_shows`.

- If a show was produced in multiple countries, count it for each of the multiple countries.

- For example, `title == "10 Days in Sun City"` is produced in `production_country == "South Africa, Nigeria"`, so that, the values of `n_shows` for `"South Africa"` and `"Nigeria"` should count `"10 Days in Sun City"`.


- If a value of country starts with an empty character, `" "`, remove the starting empty character from its value using `str_sub()`, `str_length()`, and `ifelse()`.

```{r}
q3b <- q3a %>% 
  select(starts_with("country")) %>% 
  pivot_longer(col = country_1:country_8,
               values_to = "country",
               names_to = "n") %>% 
  filter(!is.na(country)) %>% 
  select(-n) %>% 
  count(country) %>% 
  arrange(-n)

q3b <- q3b %>% 
  mutate(country = ifelse( str_sub(country, 1, 1) == " ",
                           str_sub(country, 2, str_length(country)),
                           country) ) %>% 
  group_by(country) %>% 
  summarise(n_shows = sum(n, na.rm = T) ) %>% 
  filter(country != "") %>% 
  arrange(-n_shows)
```

<br>

## Q3c.
- Add the following variable to the data.frame `netflix` or the resulting data.frame in Q3a:
  - `year_added`: year a show was added to Netflix

- Then, provide both (1) one ggplot and (2) a simple comment to describe the yearly trend of the number of the Netflix shows  produced in each of the top 10 countries from Q3b.

```{r}
q3c <- q3a %>% 
  separate(date_added, into = c("md", "year_added"),
           sep = ",",
           convert = T) %>% 
  select(year_added, starts_with("country")) %>% 
  filter(!is.na(year_added)) %>% 
  pivot_longer(col = country_1:country_8,
               values_to = "country",
               names_to = "name") %>% 
  filter(!is.na(country), country != "", country != " ") %>% 
  select(-name) %>% 
  count(country, year_added) %>% 
  arrange(country, year_added) %>% 
  mutate(country = ifelse( str_sub(country, 1, 1) == " ",
                           str_sub(country, 2, str_length(country)),
                           country) ) %>% 
  group_by(country, year_added) %>% 
  summarise(n = sum(n, na.rm = T) ) %>% 
  filter(country %in% as_vector(q3b[1:10, 1]))

ggplot(q3c,
       aes(x = year_added, y = n)) +
  geom_line(aes(x = year_added, y = n,
                color = fct_reorder2(country,
                                     year_added,
                                     n)) ) +
  geom_point()
```

