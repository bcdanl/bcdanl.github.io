<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>DANL 210 Lecture 18</title>
    <meta charset="utf-8" />
    <meta name="author" content="Byeong-Hak Choe" />
    <meta name="date" content="2023-04-13" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script src="libs/xaringanExtra-webcam-0.0.1/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <script src="libs/peerjs-1.3.1/peerjs.min.js"></script>
    <script src="libs/tiny.toast-1.0.0/toast.min.js"></script>
    <link href="libs/xaringanExtra-broadcast-0.2.6/broadcast.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-broadcast-0.2.6/broadcast.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/nhsr.css" type="text/css" />
    <link rel="stylesheet" href="css/nhsr-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, bottom

# DANL 210 Lecture 18
----
## **DANL 210: Data Preparation and Management**
### Byeong-Hak Choe
### April 13, 2023





---
class: inverse, center, middle

# Missing Data 
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Missing Data 
### &lt;p style="color:#00449E"&gt; 


Rarely will we be given a data set without any missing values.


Pandas usually displays missing values as `NaN`.
  - `NaN` is the actual representation of "Not a Number" values.
  - I would prefer calling it "Not Available" (`NA`), for which some other programming languages as well as Pandas use to represent missing values.
  

---
# Missing Data 
### &lt;p style="color:#00449E"&gt; 

- The `NaN` value in Pandas comes from Numpy.


```python
from numpy import NaN
NaN == True
NaN == 0
NaN == "
NaN == NaN
```


---
# Missing Data 
### &lt;p style="color:#00449E"&gt; 


- Pandas has functions to test for missing values, `isnull()`.
- Pandas also has functions for testing non-missing values, `notnull()`.


```python
import pandas as pd
pd.isnull(NaN)
pd.notnull(NaN)
pd.notnull(210)
pd.notnull('missing')
```



---
#  Where Can Missing Values Come From?
### &lt;p style="color:#00449E"&gt;  Load Data

.panelset[
.panel[.panel-name[read_csv()]
- When we load the data, Pandas automatically finds the missing data cell and give us a DataFrame with the `NaN` value in the appropriate cell. 

- In the `read_csv()` function, three parameters are related to reading missing values: `na_values` and `keep_default_na`.



]

.panel[.panel-name[na_values]
The `na_values` parameter allows us to specify additional missing or `NaN` values. 


  - We can pass in either a Python `str` (i.e., string) or a list-like object to be automatically coded as missing values when the file is read. 
  


```python
path = 'https://bcdanl.github.io/data/survey_visited.csv'
survey_visited_0 = pd.read_csv(path)
survey_visited_1 = pd.read_csv(path, na_values = ["MSK-4"])
```




]

.panel[.panel-name[keep_default_na]
The `keep_default_na` parameter is a `bool` (i.e., `True` or `False` boolean) that allows us to specify whether any additional values need to be considered as missing. 

- `keep_default_na = False` will only use the missing values specified in `na_values`.



```python
survey_visited_2 = pd.read_csv(path, keep_default_na = False)
```

]



]





---
#  Where Can Missing Values Come From?
### &lt;p style="color:#00449E"&gt;   Merged Data

- Let's merge `survey_visited_0` with `survey`.

```python
path = 'https://bcdanl.github.io/data/survey_survey.csv'
survey = pd.read_csv(path)
survey

vs = survey_visited_0.merge(survey, left_on='ident', right_on='taken')
vs
```



---
#  Where Can Missing Values Come From?
### &lt;p style="color:#00449E"&gt;  Reindexing

.panelset[
.panel[.panel-name[(1)]
Another way to introduce missing values into our data is to reindex our dataframe. 

  - This is useful when we want to add new indices to your dataframe, but still want to retain its original values. 
  - A common usage is when the index represents some time interval, and we want to add more dates.
  

```python
gapminder = pd.read_csv('https://bcdanl.github.io/data/gapminder.tsv', sep='\t')
life_exp = gapminder.groupby(['year'])['lifeExp'].mean()
```

]

.panel[.panel-name[(2)]
-  We can reindex the dataframe by using the `.reindex()` method.


```python
# subset
y2000 = life_exp[life_exp.index &gt; 2000]

# reindexing
y2000.reindex(range(2000, 2010))
```

]

]







---
#   Working With Missing Data
### &lt;p style="color:#00449E"&gt;  Find and Count Missing Data

.panelset[
.panel[.panel-name[.count()]
One way to look at the number of missing values is to `count()` them.


```python
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv')
# count the number of non-missing values
ebola.count()
```

**Q**. Count the number of non-missing values for each variable in `ebola`.


]

.panel[.panel-name[np.count_nonzero()]
If we want to count the total number of missing values in our DataFrame, or count the number of missing values for a particular column, we can use the `np.count_nonzero()` function from numpy in conjunction with the `.isnull()` method.


```python
np.count_nonzero(ebola.isnull())
np.count_nonzero(ebola['Cases_Guinea'].isnull())
```



]

.panel[.panel-name[.value_counts(dropna=False)]

Another way to get missing data counts is to use the `.value_counts()` method, giving a frequency table of values in a Series. 
  - If we use the `dropna = False`, we can also get a missing value count.


```python
cnts = ebola['Cases_Guinea'].value_counts(dropna=False)
cnts
```

- The results are sorted so we can subset the count vector to just look at the missing values.


```python
cnts.loc[pd.isnull(cnts.index)]
```

]



.panel[.panel-name[.sum()]

- In Python, `True` values equate to the integer value 1, and `False` values equate to the integer value 0. 
  - We can use this behavior to get the number of missing values by summing up a boolean vector with the `.sum()` method.


```python
ebola.Cases_Guinea.isnull().sum()
```

]
]




---
#   Working With Missing Data
### &lt;p style="color:#00449E"&gt;   Clean Missing Data

.panelset[
.panel[.panel-name[Cleaning NaN]

There are many different ways we can deal with missing data. 
  1. We can replace the missing value with another value, 
  2. We can fill in the cells with the missing value using existing value, 
  3. We can drop the observations with missing values from our DataFrame.
]


.panel[.panel-name[.fillna()]
- We can use the `.fillna()` method to recode the missing values to another value.


```python
# fill the missing values to 0
ebola0 = ebola.fillna(0)
```

]


.panel[.panel-name[.fillna(method='ffill')]

- We can use built-in methods to fill forward (`method = ffill`).

  -  When we fill data forward, the last known value (from top to bottom) is used for the next missing value.
  


```python
ebola_f = ebola.fillna(method='ffill')
```

]


.panel[.panel-name[.fillna(method='bfill')]

- We can also use built-in methods to fill backward (`method = bfill`).

  -  When we fill data backward, the newest value (from top to bottom) is used to replace the missing data.


```python
ebola_b = ebola.fillna(method='bfill')
```

]


.panel[.panel-name[.interpolate()]
- Interpolation uses existing values to fill in missing values.
  - By default, `.interpolate()` treats the missing values as if they should be equally spaced apart.

```python
ebola_linear = ebola.interpolate()
```

- The `.interpolate()` method  behaves kind of in a forward fill fashion.

]


.panel[.panel-name[.dropna()]

If we want to keep the observations with only non-missing values, we can use `.dropna()`

```python
ebola_dropna = ebola.dropna()
```

We are left with just one row of data!
]


.panel[.panel-name[Calculation]

Suppose we wanted to look at the case counts for multiple regions. 

.pull-left[

```python
ebola["Cases_multiple"] = (
  ebola["Cases_Guinea"]
  + ebola["Cases_Liberia"]
  + ebola["Cases_SierraLeone"]
)
```
]

.pull-right[

```python
ebola_subset = ebola.loc[:,
    ["Cases_Guinea", 
     "Cases_Liberia", 
     "Cases_SierraLeone",
     "Cases_multiple"] ]
```
]  


]


.panel[.panel-name[skipna]

`.mean()` and `.sum()` can ignore missing values. 
  - These functions will typically have a `skipna` parameter that will still calculate a value by skipping over the missing values.


```python
ebola.Cases_Guinea.sum(skipna = True) # default
ebola.Cases_Guinea.sum(skipna = False)
```




]


]





---
#   Working With Missing Data
### &lt;p style="color:#00449E"&gt;    Pandas Built-In `NA` Missing

Pandas 1.0 introduced a built-in `&lt;NA&gt;` value (`pd.NA`).


```python
economists = pd.DataFrame(
  {
    "Name": ["John Forbes Nash", "William Nordhaus"],
    "Occupation": ["Mathematician", "Climate Economist"],
    "Born": ["1928-06-13", "1941-05-31"],
    "Died": ["2015-05-23", ""],
    "Age": [86, 81]
  }
)

economists.loc[1, "Age"] = pd.NA
```


---
class:  center, middle

# Attendance Time

Let's have an attendance time.



---
class: inverse, center, middle

# Strings and Text Data
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Dates and Times
### &lt;p style="color:#00449E"&gt;  Python's `datetime` Object

One of the bigger reasons for using Pandas is its ability to work with timeseries data.

- We can use `datetime` to get the current date and time.


```python
from datetime import datetime
now = datetime.now()
```

- We can also create our own `datetime` manually.


```python
t1 = datetime.now()
t2 = datetime(2000,1,1)

diff = t1 - t2
type(diff)
```


---
# Dates and Times
### &lt;p style="color:#00449E"&gt;   Converting to datetime
.panelset[
.panel[.panel-name[data]

-  Let’s load up our Ebola data set and convert the Date column into a proper datetime object.

```python
import pandas as pd
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv')
ebola.info()
```

- The `Date` column is encoded as a generic string `object`.
]
.panel[.panel-name[`.to_datatime()`]
- 
We can use `.to_datatime()` to create a new column, `date_dt`, that converts the `Date` column into a `datetime`.


```python
ebola['date_dt'] = pd.to_datetime(ebola['Date'])
```

]
.panel[.panel-name[format]

- The `to_datetime()` method has a parameter called `format` that allows us to manually specify the format of the date.

```ptyhon

ebola['date_dt'] = pd.to_datetime(ebola['Date'], format='%m /%d/%Y')

ebola['date_my'] = pd.to_datetime(ebola['Date'], format='%m /%Y')
```

]
.panel[.panel-name[parse_dates]
 The `read_csv()` function has several parameters about `datetime`.
  -  We can parse the `Date` column directly by specifying the column we want in the `parse_dates` parameter.

```python
ebola = pd.read_csv('https://bcdanl.github.io/data/country_timeseries.csv', parse_dates=["Date"])
```

]

]


---
# Dates and Times
### &lt;p style="color:#00449E"&gt; Extracting Date Components


Now that we have a datetime object, we can extract various parts of the date, such as **year**, **month**, or **day**.

Let's consider the example `datetime` object.


```python
d = pd.to_datetime('2021-12-14')
type(d)
d.year
d.month
d.day
d.quarter
```



---
# Dates and Times
### &lt;p style="color:#00449E"&gt; Extracting Date Components in DataFrame

- We can extract various parts of the `datetime` column in DataFrame by accessing `datetime` methods using the `.dt` accessor.


```python
ebola['date_dt'] = pd.to_datetime(ebola['Date'])

ebola = ebola.assign(
    year = ebola["date_dt"].dt.year,
    month = ebola["date_dt"].dt.month,
    day = ebola["date_dt"].dt.day
)

ebola.info() # what are the data types of year, month, and day?
```




---
# Dates and Times
### &lt;p style="color:#00449E"&gt; Date Ranges
.panelset[
.panel[.panel-name[(1)]

- In our Ebola data set, we do not have an observation for every day in the date range.
  - This is quite common.


```python
ebola = pd.read_csv(
'https://bcdanl.github.io/data/country_timeseries.csv', parse_dates=["Date"]
)
```

- Here, `2015-01-01` is missing.
]


.panel[.panel-name[(2)]
- It’s common practice to create a date range to `.reindex()` a data set. 
  - We can use the `date_range()`.
  

```python
head_range = pd.date_range(start='2014-12-31', end='2015-01-05')
ebola_5 = ebola.head()
ebola_5.index = ebola_5['Date']
ebola_5 = ebola_5.reindex(head_range)
```


]


.panel[.panel-name[(3)]
  

```python
ebola = pd.read_csv(
  "https://bcdanl.github.io/data/country_timeseries.csv",
  index_col="Date",
  parse_dates=["Date"],
)

new_idx = pd.date_range(ebola.index.min(), ebola.index.max())
new_idx = reversed(new_idx) # to reverse new_idx
ebola = ebola.reindex(new_idx)
```


]

]



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!--Hat-tip: https://www.garrickadenbuie.com/blog/xaringan-tip-logo-all-slides/-->
<style>
.logo {
  background-image: url(img/logo-blue.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 66px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
