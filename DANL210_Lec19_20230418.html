<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>DANL 210 Lecture 19</title>
    <meta charset="utf-8" />
    <meta name="author" content="Byeong-Hak Choe" />
    <meta name="date" content="2023-04-18" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script src="libs/xaringanExtra-webcam-0.0.1/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <script src="libs/peerjs-1.3.1/peerjs.min.js"></script>
    <script src="libs/tiny.toast-1.0.0/toast.min.js"></script>
    <link href="libs/xaringanExtra-broadcast-0.2.6/broadcast.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-broadcast-0.2.6/broadcast.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/nhsr.css" type="text/css" />
    <link rel="stylesheet" href="css/nhsr-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, bottom

# DANL 210 Lecture 19
----
## **DANL 210: Data Preparation and Management**
### Byeong-Hak Choe
### April 18, 2023

---
class: inverse, center, middle

# Web-scrapping 
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Ethical considerations

&gt; *"If you can see things in your web browser, you can scrape 
them."*

- Just because you can scrape them doesn't mean you should.
  - It is currently legal to scrape data from the web using automated tools, as long as the data are publicly available.
    - hiQ Labs vs. LinkedIn Corp. court ruling.
 
 
- It’s important to realize that the web scrapping tools are very powerful.
  - It’s pretty easy to write up a program that can overwhelm a host server.
  - The host server tends to have built-in safeguards that will block you in case of a suspected malicious attack.


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Clients and servers

- Computers connected to the web are called **clients** and **servers**.

&lt;img src="lec_figs/client_server.png" width="50%" style="display: block; margin: auto;" /&gt;


- **Clients** are the typical web user’s internet-connected devices (e.g., a computer connected to Wi-Fi) and web-accessing software available on those devices (e.g., Firefox, Chrome).
- **Servers** are computers that store webpages, sites, or apps.


- When a client device wants to access a webpage, a copy of the webpage is downloaded from the server onto the client machine to be displayed in the user’s web browser.



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTTP

- **Hypertext Transfer Protocol (HTTP)** is a language for clients and servers to speak to each other.


- When we type a web address into our browser:
  - The browser finds the address of the server that the website lives on.
  - The browser sends an HTTP request message to the server, asking it to send a copy of the website to the client.
  - If the server approves the client’s request, the server sends the client a `200 OK` message, and then starts displaying the website in the browser.


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; URL

.panelset[
.panel[.panel-name[(1)]


- A Uniform Resource Locator (URL) is usually composed of 5 parts:
&lt;img src="lec_figs/URL.png" width="75%" style="display: block; margin: auto;" /&gt;
- The URL—commonly know as a “web address”, specifies the location of a resource (such as a web page) on the internet.


]

.panel[.panel-name[(2)]

- A Uniform Resource Locator (URL) is usually composed of 5 parts:
&lt;img src="lec_figs/URL.png" width="75%" style="display: block; margin: auto;" /&gt;
- The 4th part, the “query string”, contains one or more parameters — in this case, there are two parameters: `id` and `cat`. 


]

.panel[.panel-name[(3)]

- A Uniform Resource Locator (URL) is usually composed of 5 parts:
&lt;img src="lec_figs/URL.png" width="75%" style="display: block; margin: auto;" /&gt;
- The 5th part, the “fragment”, is an internal page reference and may not be present.


]

]




---
class: inverse, center, middle

# HTML
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML

.panelset[
.panel[.panel-name[(1)]
- **Hyper Text Markup Language (HTML)** is the standard markup language for creating Web pages. 
  - HTML describes the structure of a Web page.  
  - HTML consists of a series of elements. 
  - HTML elements tell the browser how to display the content.


- HTML elements label pieces of content such as “this is a heading”, “this is a paragraph”, “this is a link”, etc.


]

.panel[.panel-name[(2)]
- Below is a simple HTML document:


```html
&lt;!DOCTYPE html&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Page Title&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;My First Heading&lt;/h1&gt;
      &lt;p&gt;My first paragraph.&lt;/p&gt;
    &lt;/body&gt;
  &lt;/html&gt;
```

]


.panel[.panel-name[(3)]
- `&lt;!DOCTYPE html&gt;` declaration defines that this document is an HTML document. 
- `&lt;html&gt;` element is the root element of an HTML page. 
- `&lt;head&gt;` element contains meta information about the HTML page. 
- `&lt;title&gt;` element specifies a title for the HTML page.
  - `&lt;title&gt;` is shown in the browser’s title bar or in the page’s tab.
]



.panel[.panel-name[(4)]
- `&lt;body&gt;` element defines the document’s body, and is a container for all the visible contents, such as headings, paragraphs, images, hyperlinks, tables, lists, etc. 
  - `&lt;h1&gt;` element defines a large heading. 
  - `&lt;p&gt;` element defines a paragraph.
]



]







---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML body

.panelset[
.panel[.panel-name[tagname]


- An HTML element is defined by a start tag, some content, and an end tag:



```html
&lt;tagname&gt;Content goes here...&lt;/tagname&gt;
```


]


.panel[.panel-name[a]
- The `&lt;a&gt;` tag defines an HTML link.



```html
&lt;a href="https://www.w3schools.com"&gt;This is a link&lt;/a&gt;
```


]


.panel[.panel-name[img]
- The `&lt;img&gt;` tag defines an HTML image.



```html
&lt;img src="w3schools.jpg" alt="W3Schools.com" width="104" height="142"&gt;
```

]

]



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML table

.panelset[
.panel[.panel-name[(1)]

- `&lt;table&gt;` tag defines an HTML table.
  - `&lt;tr&gt;` tag defines each table row.
  - `&lt;th&gt;` tag defines each table header.
  - `&lt;td&gt;` tag defines each data/cell.


]

.panel[.panel-name[(2)]

- Below is the example HTML table:

```html
&lt;table style="width:100%"&gt;
  &lt;tr&gt;
    &lt;th&gt;Firstname&lt;/th&gt;
    &lt;th&gt;Lastname&lt;/th&gt; 
    &lt;th&gt;Age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Eve&lt;/td&gt;
    &lt;td&gt;Jackson&lt;/td&gt;
    &lt;td&gt;94&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
```


]

]



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML lists

.panelset[
.panel[.panel-name[unordered lists]
- `&lt;ul&gt;` tag defines an unordered lists.
  - `&lt;li&gt;` tag defines each list item.
  - The list items will be marked with bullets (small black circles) by default.



```html
&lt;ul&gt;
  &lt;li&gt;Coffee&lt;/li&gt;
  &lt;li&gt;Tea&lt;/li&gt;
  &lt;li&gt;Milk&lt;/li&gt;
&lt;/ul&gt;
```
]
.panel[.panel-name[ordered lists]
- `&lt;ol&gt;` tag defines an ordered lists.
  - `&lt;li&gt;` tag defines each list item.
  - The list items will be marked with numbers by default.



```html
&lt;ol&gt;
  &lt;li&gt;Coffee&lt;/li&gt;
  &lt;li&gt;Tea&lt;/li&gt;
  &lt;li&gt;Milk&lt;/li&gt;
&lt;/ol&gt;
```

]
]




---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML display values: `&lt;div&gt;`

- A block-level element always starts on a new line and takes up the full width available. 
  - The `&lt;div&gt;` element is a block-level and is often used as a container for other HTML elements. 
  - The `&lt;div&gt;` element has no required attributes, but style, class and id are common. 


```html
&lt;div style="background-color:black;color:white;padding:20px;"&gt;
  &lt;h2&gt;London&lt;/h2&gt;
  &lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;
&lt;/div&gt;
```


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML display values: `&lt;span&gt;`

- An inline element does not start on a new line and it only takes up as much width as necessary. 
  - The `&lt;span&gt;` element is an inline container used to mark up a part of a text, or a part of a document. 
  - The `&lt;span&gt;` element has no required attributes, but style, class and id are common.


```html
&lt;p&gt;My mother has &lt;span style="color:blue;font-weight:bold"&gt;blue&lt;/span&gt; eyes and my father has &lt;span style="color:darkolivegreen;font-weight:bold"&gt;dark green&lt;/span&gt; eyes.&lt;/p&gt;
```




---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; HTML


- HTML elements can be nested (this means that elements can contain other elements). 
  - All HTML documents consist of nested HTML elements. 


- We can view HTML source for web page.
  - Hit **F12** key (in Chrome or FireFox).
  - Right-click in an HTML page and select `View Page Source` (in Chrome), or similar in other browsers. 
  - Right-click on an element (or a blank area), and choose `Inspect` or `Inspect Element` to see what elements are made up of. 


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; DOM
.panelset[
.panel[.panel-name[(1)]
- To parse HTML, it is convenient to represent our HTML document as a tree-like structure that contains information in **nodes** and links information through **branches**. 


- This tree-like structure is called the **Document Object Model (DOM)**.
  - DOM is a cross-platform and language-independent interface that treats an XML (eXtensible Markup Language) or HTML document as a tree structure wherein each node is an object representing a part of the document.

]

.panel[.panel-name[XML]
- XML: XML is a software- and hardware-independent tool for storing and transporting data. 
  - XML is a markup language much like HTML. 


- XML and HTML were designed with different goals: 
  - XML was designed to carry data with focus on what data is. 
  - HTML was designed to display data with focus on how data looks.

]

.panel[.panel-name[(2)]

&lt;img src="lec_figs/DOM.png" width="50%" style="display: block; margin: auto;" /&gt;


]



.panel[.panel-name[(3)]

.pull-left[

&lt;img src="lec_figs/html-code.png" width="75%" style="display: block; margin: auto;" /&gt;

]

--

.pull-right[

&lt;img src="lec_figs/html-web.png" width="50%" style="display: block; margin: auto;" /&gt;


]


]


]



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; JavaScript (JS) and Cascading Style Sheets (CSS)

.panelset[
.panel[.panel-name[JS]
- JavaScript (JS) is a client-side programming language.
  - JS helps encourage interactivity on the website.
  - JS runs on the user’s browser instead of on the server as well as often uses 3rd party libraries, so it can increase the functionality of the website.

]
.panel[.panel-name[CSS]
- Cascading Style Sheets (CSS) is used to format the layout of a webpage (color, font, text size, background, display, etc.). 
  - HTML will format the architecture of the house;
  - CSS will be the carpet and walls to decorate the house;
  - JS adds interactive elements in the house, such as opening doors and lighting.

]


]

---
class: inverse, center, middle

# Selenium Web-scrapping 
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; WebDriver

.panelset[
.panel[.panel-name[WebDriver]

- **WebDriver** is an wire protocol that defines a language-neutral interface for controlling the behaviour of web browsers. 


- Selenium WebDriver refers to both the language bindings and the implementations of the individual browser controlling code and commonly referred as WebDriver.


- Each browser is backed by a specific WebDriver implementation, called a driver (or a browser driver). 

]

.panel[.panel-name[Driver]

- The **driver** is the component responsible for delegating down to the browser, and handles communication to and from Selenium WebDriver and the browser. 


- The driver is browser-specific:
  - ChromeDriver for Chrome;
  - GeckoDriver for FireFox.

]

.panel[.panel-name[Interaction]

- A simplified diagram of how WebDriver interacts with browser might look like this:

&lt;img src="lec_figs/driver.png" width="35%" style="display: block; margin: auto;" /&gt;

- WebDriver talks to a browser through a driver and the communication is two way:
  - WebDriver sends commands to the browser through the driver, and receives information back via the same route.
]

]


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Setting up

.panelset[
.panel[.panel-name[(1)]

- Selenium works by automating browsers to load the website, retrieve the required data, and even take certain actions on the website. 


*1*. Downloads the appropriate version of the ChromeDriver file ([https://chromedriver.chromium.org/downloads](https://chromedriver.chromium.org/downloads)) or the gecokdriver file ([https://github.com/mozilla/geckodriver/releases](https://github.com/mozilla/geckodriver/releases)) for your operating system (Windows or MacOS).

]

.panel[.panel-name[(2)]

*2*. It is recommended that we place the web driver file on the main folder containing the Python codes.

  - Install Chrome or FireFox if you do not have either of them.
  - Install Selenium using `pip`:
    -  `pip install selenium`

]


.panel[.panel-name[Mac]


- Mac users should allow the web driver to be opened.

1. Open (or double click) the web driver file (`chromedriver` or `geckodriver`) from the Finder.
2. Click Apple logo on the left top corner.
3. Click "System Preferences ...".
4. Click "Security &amp; Privacy".
5. Click "General".
6. Click "Open Anyway".

]

]

---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Setting up

.panelset[
.panel[.panel-name[working directory]
- We can use `os.chdir()` to set the working directory 
  - `os.chdir()` changes the current working directory to the specified path. 

```python
import os
wd_path = 'YOUR_PATH_TO_WORKING_DIRECTORY'
os.chdir(wd_path)  
os.getcwd()
```


]
.panel[.panel-name[webdriver.Chrome()]

- To begin with, we import `WebDriver` from Selenium, and set a path to `chromedriver`.

  - The `webdriver.Chrome()` with the path of `chromedriver` creates an object of the `selenium.webdriver.chrome.webdriver.WebDriver`.
  

]

.panel[.panel-name[webdriver.Chrome()]


```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options

options = Options()
options.add_argument("window-size=1400,1200")

driver_path = "YOUR_PATH_TO_chromedriver"
driver = [?](chrome_options = options, 
             executable_path = driver_path)
```


]

.panel[.panel-name[get()]
- `get()` from `WebDriver` with a URL opens Google Chrome. 
  - In your browser, you may the message, "Chrome is being controlled by automated test software."
- `close()` terminates the loaded browser window. 
- `quit()` ends the `WebDriver` application.

```python
url = "https://qavbox.github.io/demo/webtable/"
driver.[?](form_url)
driver.close()
driver.quit()
```

]
]



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Locating Web Elements by `Inspect`-`find_element()`

.panelset[
.panel[.panel-name[(1)]
- After the new Google Chrome window is loaded with the URL provided, we can find the elements that we need to act on. 

  - The easiest way to identify the information is to `Inspect` pages using developer tools.

]


.panel[.panel-name[(2)]
- Place the cursor anywhere on the webpage, right-click to open a pop-up menu, then select the `Inspect` option.


  -  In the `Elements` window, move the cursor over the DOM structure of the page until it reaches the desired element. 
  
  
  - We then need to find information such as what HTML tag is used for the element, the defined attribute, and the values for the attributes and the structure of the page.

]

]








---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.ID, "")`

.panelset[
.panel[.panel-name[(1)]

- `find_element(By.ID, "")` &amp; `find_elements(By.ID, "")`:
  - Return element(s) that have matching ID attribute values.


- Here is the HTML code for main part of the web-page with an ID attribute value defined as `form1`:


```html
&lt;form id="form1"&gt;...&lt;/form&gt;
```

]


.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.ID, "")` method to find the form table.



```python
form = driver.find_element(By.ID, "form1")
form.text  # text attribute if there is any
```

]

]

---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.CLASS_NAME, "")`


.panelset[
.panel[.panel-name[(1)]

- `find_element(By.CLASS_NAME, "")` &amp; `find_elements(By.CLASS_NAME, "")`:
  - Return element(s) that have matching class attribute value(s).


- Here is the HTML code for the home button with a class attribute value defined as `homebtn`:


```html
&lt;div class="homebtn" align="center"&gt;...&lt;/div&gt;
```

]

.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.CLASS_NAME, "")` method to find the home button.



```python
home_button = driver.find_element(By.CLASS_NAME, "homebtn")
home_button.click() # click the home_button object
driver.back() # back to the previous page
```


]


]


---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.NAME, "")`


.panelset[
.panel[.panel-name[(1)]
- `find_element(By.NAME, "")` &amp; `find_elements(By.NAME, "")`:
  - Return element(s) that have matching name attribute value(s).



- Here is the HTML code for the home button with a name attribute value defined as `home`:



```html
&lt;input type="button" class="btn" name="home" value="Home" /&gt;
```


]

.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.NAME, "")` method to find the home button.



```python
home_button2 = driver.find_element(By.NAME, "home")
home_button2.click()
driver.back()
```


]



]







---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.CSS_SELECTOR, "")`


.panelset[
.panel[.panel-name[(1)]

- `find_element(By.CSS_SELECTOR, "")` &amp; `find_elements(By.CSS_SELECTOR, "")`:
  - Return element(s) that are found by the specified CSS selector. 
  
  

]

.panel[.panel-name[(2)]

- To find the CSS selector of the search button, we `Inspect` the example site, in the *Elements* window, move the cursor over its DOM structure and find the search element. 
  - We then right-click and choose *Copy Selector* from the pop-up menu. 
  - We obtain the following CSS selector of this element:
  

```python
home_button3 = driver.find_element(By.CSS_SELECTOR, "body &gt; div &gt; a &gt; input")
home_button3.click()
driver.back()
```

]



]






---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.TAG_NAME, "")`


.panelset[
.panel[.panel-name[(1)]
- `find_element(By.TAG_NAME, "")` &amp; `find_elements(By.TAG_NAME, "")`:
  - Return element(s) that are found by the specified tag. 

]

.panel[.panel-name[(2)]

.pull-left[
- The following example page displays a table which has several form fields to fill in.
  -  Each form field name is implemented using an `&lt;th&gt;` or table header cell tag inside a `&lt;tr&gt;` or table row tag:

]

.pull-right[

&lt;img src="lec_figs/find_tag1.png" width="100%" style="display: block; margin: auto;" /&gt;
]



]


.panel[.panel-name[(3)]
- Here is an example that uses the `find_element(By.TAG_NAME, "")` method to find the head of the table.



```python
table01 = driver.find_element(By.ID, "table01")
thead = table01.find_element(By.TAG_NAME, "thead")
thead.text
```


]

]






---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.LINK_TEXT, "")`

.panelset[
.panel[.panel-name[(1)]
- `find_element(By.LINK_TEXT, "")` &amp; `find_elements(By.LINK_TEXT, "")`:
  - Find link(s) using the text displayed for the link. 

]

.panel[.panel-name[(2)]
- For example, we may want to get the **Selenium** displayed on the example site. 
  - Here is the HTML code for the **Selenium** implemented as the `&lt;a&gt;`, or anchor tag, with text **"Selenium"**:



```html
&lt;a href="http://www.selenium.dev/"&gt;Selenium&lt;/a&gt;
```

]


.panel[.panel-name[(3)]
-  Here is an example that uses the `find_element(By.LINK_TEXT, "")` method to find **Selenium**.



```python
selenium_link = driver.find_element(By.LINK_TEXT, "Selenium")
selenium_link.click()
```


]

]



---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.PARTIAL_LINK_TEXT, "")`


.panelset[
.panel[.panel-name[(1)]
- Sometimes, there can be several link texts that contain a common word in the webpage.


- `find_element(By.PARTIAL_LINK_TEXT, "")` &amp; `find_elements(By.PARTIAL_LINK_TEXT, "")`:
  - Find link(s) using partial text. 


]

.panel[.panel-name[(2)]
- Let us use this method to find these links using the `"qav"` text and check whether we have two of these links available on the page.


```python
Selen_links = driver.find_elements(By.PARTIAL_LINK_TEXT, "qav")
print(len(Selen_links))
Selen_links[0].click()
driver.back()
```
]


]


---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.XPATH, "")`

.panelset[
.panel[.panel-name[(1)]
- `find_element(By.XPATH, "")` &amp; `find_element(By.XPATH, "")`:
  - Return element(s) that are found by the specified XPath query. 


- XPath is a query language used to search and locate nodes in a XML document.
  - All major web browsers support XPath. 
  - Selenium can leverage and use powerful XPath queries to find elements on a web page. 
  - One of the advantages of using XPath is when we can’t find a suitable ID, name, or class attribute value for the element. 

]

.panel[.panel-name[(2)]
- We can use *XPath* to either find the element in absolute terms or relative to an element that does have an ID or name attribute.


- We can also use defined attributes other than the ID, name, or class with *XPath* queries. 


]


.panel[.panel-name[(3)]

- For example, we want to get the second table. 

  - The body of this table consists of a series of `&lt;tr&gt;` tags, but does not have the ID, name, or class attributes defined.
  
  - Also, we cannot use the `find_element(By.TAG_NAME, "")` method as there are multiple `&lt;tr&gt;` and `&lt;th&gt;` tags defined on the page.
]


.panel[.panel-name[(4)]

- To find the XPath of this element, we `Inspect` the example site, in the Elements window, move the cursor over its DOM structure and find the desired element. 

  - We then right-click and choose copy XPath from the pop-up menu. 
  
  - We obtain the following XPath of the first row and the first column of the table body:



```html
//*[@id="table02"]/tbody/tr[1]/td[1]
```

]


.panel[.panel-name[(5)]
- We then pass this XPath to the `find_element(By.XPATH, "")` method as an argument:
  - Find the XPath for "Tiger Nixon" in the second table.


```python
elt = driver.find_element(By.XPATH, '//*[@id="table02"]/tbody/tr[1]/td[1]')
elt.text
```

]

.panel[.panel-name[(6)]
- We typically use the XPath method when there exists an element with a unique id on the path to the desired element. 
  - Otherwise, this method is not reliable.


]

]

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!--Hat-tip: https://www.garrickadenbuie.com/blog/xaringan-tip-logo-all-slides/-->
<style>
.logo {
  background-image: url(img/logo-blue.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 66px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
