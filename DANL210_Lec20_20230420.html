<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>DANL 210 Lecture 20</title>
    <meta charset="utf-8" />
    <meta name="author" content="Byeong-Hak Choe" />
    <meta name="date" content="2023-04-20" />
    <script src="libs/header-attrs-2.20/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script src="libs/xaringanExtra-webcam-0.0.1/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <script src="libs/peerjs-1.3.1/peerjs.min.js"></script>
    <script src="libs/tiny.toast-1.0.0/toast.min.js"></script>
    <link href="libs/xaringanExtra-broadcast-0.2.6/broadcast.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-broadcast-0.2.6/broadcast.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/nhsr.css" type="text/css" />
    <link rel="stylesheet" href="css/nhsr-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, bottom

# DANL 210 Lecture 20
----
## **DANL 210: Data Preparation and Management**
### Byeong-Hak Choe
### April 20, 2023


---
# Announcement
### &lt;p style="color:#00449E"&gt; Career Expo

- The Career Design Center is hosting a **Career Expo** today (Thurs., April 20th), **5-7 pm** in the **Union Ballroom**.

  - This is an informal event for all students (all majors and class years) offering an opportunity to explore different careers by connecting with a range of industry professionals. 
  - Employers attending will bring information about their companies to share with students. 
  - Resumes are not required, but students can bring them if they would like to.



---
class: inverse, center, middle

# Web-scrapping 
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Ethical considerations

&gt; *"If you can see things in your web browser, you can scrape 
them."*

- Just because you can scrape them doesn't mean you should.
  - It is currently legal to scrape data from the web using automated tools, as long as the data are publicly available.
    - hiQ Labs vs. LinkedIn Corp. court ruling.
 
 
- It’s important to realize that the web scrapping tools are very powerful.
  - It’s pretty easy to write up a program that can overwhelm a host server.
  - The host server tends to have built-in safeguards that will block you in case of a suspected malicious attack.



---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Ethical considerations

- Respect for website owners' terms of service.
- Respect for copyright and intellectual property.
- Respect for client servers.
- Respect for privacy.


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Clients and servers

- Computers connected to the web are called **clients** and **servers**.

&lt;img src="lec_figs/client_server.png" width="50%" style="display: block; margin: auto;" /&gt;


- **Clients** are the typical web user’s internet-connected devices (e.g., a computer connected to Wi-Fi) and web-accessing software available on those devices (e.g., Firefox, Chrome).
- **Servers** are computers that store webpages, sites, or apps.


- When a client device wants to access a webpage, a copy of the webpage is downloaded from the server onto the client machine to be displayed in the user’s web browser.


---
class: inverse, center, middle

# Selenium Web-scrapping 
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; WebDriver

.panelset[
.panel[.panel-name[WebDriver]

- **WebDriver** is an wire protocol that defines a language-neutral interface for controlling the behaviour of web browsers. 


- Selenium WebDriver refers to both the language bindings and the implementations of the individual browser controlling code and commonly referred as WebDriver.


- Each browser is backed by a specific WebDriver implementation, called a driver (or a browser driver). 

]

.panel[.panel-name[Driver]

- The **driver** is the component responsible for delegating down to the browser, and handles communication to and from Selenium WebDriver and the browser. 


- The driver is browser-specific:
  - ChromeDriver for Chrome;
  - GeckoDriver for FireFox.

]

.panel[.panel-name[Interaction]

- A simplified diagram of how WebDriver interacts with browser might look like this:

&lt;img src="lec_figs/driver.png" width="35%" style="display: block; margin: auto;" /&gt;

- WebDriver talks to a browser through a driver and the communication is two way:
  - WebDriver sends commands to the browser through the driver, and receives information back via the same route.
]

]


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Setting up

.panelset[
.panel[.panel-name[(1)]

- Selenium works by automating browsers to load the website, retrieve the required data, and even take certain actions on the website. 


*1*. Downloads the appropriate version of the ChromeDriver file ([https://chromedriver.chromium.org/downloads](https://chromedriver.chromium.org/downloads)) or the gecokdriver file ([https://github.com/mozilla/geckodriver/releases](https://github.com/mozilla/geckodriver/releases)) for your operating system (Windows or MacOS).

]

.panel[.panel-name[(2)]

*2*. It is recommended that we place the web driver file on the main folder containing the Python codes.

  - Install Chrome or FireFox if you do not have either of them.
  - Install Selenium using `pip`:
    -  `pip install selenium`

]


.panel[.panel-name[Mac]


- Mac users should allow the web driver to be opened.

1. Open (or double click) the web driver file (`chromedriver` or `geckodriver`) from the Finder.
2. Click Apple logo on the left top corner.
3. Click "System Preferences ...".
4. Click "Security &amp; Privacy".
5. Click "General".
6. Click "Open Anyway".

]

]

---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Setting up

.panelset[
.panel[.panel-name[working directory]
- We can use `os.chdir()` to set the working directory 
  - `os.chdir()` changes the current working directory to the specified path. 

```python
import os
wd_path = 'YOUR_PATH_TO_WORKING_DIRECTORY'
os.chdir(wd_path)  
os.getcwd()
```


]
.panel[.panel-name[webdriver.Chrome()]

- To begin with, we import `WebDriver` from Selenium, and set a path to `chromedriver`.

  - The `webdriver.Chrome()` with the path of `chromedriver` creates an object of the `selenium.webdriver.chrome.webdriver.WebDriver`.
  

]

.panel[.panel-name[webdriver.Chrome()]


```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options

options = Options()
options.add_argument("window-size=1400,1200")

driver_path = "YOUR_PATH_TO_chromedriver"
driver = [?](chrome_options = options, 
             executable_path = driver_path)
```


]

.panel[.panel-name[get()]
- `get()` from `WebDriver` with a URL opens Google Chrome. 
  - In your browser, you may the message, "Chrome is being controlled by automated test software."
- `close()` terminates the loaded browser window. 
- `quit()` ends the `WebDriver` application.

```python
url = "https://qavbox.github.io/demo/webtable/"
driver.[?](form_url)
driver.close()
driver.quit()
```

]
]



---
class:  center, middle

# Attendance Time

Let's have an attendance time.


---
# Web Scrapping
### &lt;p style="color:#00449E"&gt; Locating Web Elements by `Inspect`-`find_element()`

.panelset[
.panel[.panel-name[(1)]
- After the new Google Chrome window is loaded with the URL provided, we can find the elements that we need to act on. 

  - The easiest way to identify the information is to `Inspect` pages using developer tools.

]


.panel[.panel-name[(2)]
- Place the cursor anywhere on the webpage, right-click to open a pop-up menu, then select the `Inspect` option.


  -  In the `Elements` window, move the cursor over the DOM structure of the page until it reaches the desired element. 
  
  
  - We then need to find information such as what HTML tag is used for the element, the defined attribute, and the values for the attributes and the structure of the page.

]

]








---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.ID, "")`

.panelset[
.panel[.panel-name[(1)]

- `find_element(By.ID, "")` &amp; `find_elements(By.ID, "")`:
  - Return element(s) that have matching ID attribute values.


- Here is the HTML code for main part of the web-page with an ID attribute value defined as `form1`:


```html
&lt;form id="form1"&gt;...&lt;/form&gt;
```

]


.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.ID, "")` method to find the form table.



```python
form = driver.find_element(By.ID, "form1")
form.text  # text attribute if there is any
```

]

]

---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.CLASS_NAME, "")`


.panelset[
.panel[.panel-name[(1)]

- `find_element(By.CLASS_NAME, "")` &amp; `find_elements(By.CLASS_NAME, "")`:
  - Return element(s) that have matching class attribute value(s).


- Here is the HTML code for the home button with a class attribute value defined as `homebtn`:


```html
&lt;div class="homebtn" align="center"&gt;...&lt;/div&gt;
```

]

.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.CLASS_NAME, "")` method to find the home button.



```python
home_button = driver.find_element(By.CLASS_NAME, "homebtn")
home_button.click() # click the home_button object
driver.back() # back to the previous page
```


]


]


---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.NAME, "")`


.panelset[
.panel[.panel-name[(1)]
- `find_element(By.NAME, "")` &amp; `find_elements(By.NAME, "")`:
  - Return element(s) that have matching name attribute value(s).



- Here is the HTML code for the home button with a name attribute value defined as `home`:



```html
&lt;input type="button" class="btn" name="home" value="Home" /&gt;
```


]

.panel[.panel-name[(2)]
- Here is an example that uses the `find_element(By.NAME, "")` method to find the home button.



```python
home_button2 = driver.find_element(By.NAME, "home")
home_button2.click()
driver.back()
```


]



]







---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.CSS_SELECTOR, "")`


.panelset[
.panel[.panel-name[(1)]

- `find_element(By.CSS_SELECTOR, "")` &amp; `find_elements(By.CSS_SELECTOR, "")`:
  - Return element(s) that are found by the specified CSS selector. 
  
  

]

.panel[.panel-name[(2)]

- To find the CSS selector of the search button, we `Inspect` the example site, in the *Elements* window, move the cursor over its DOM structure and find the search element. 
  - We then right-click and choose *Copy Selector* from the pop-up menu. 
  - We obtain the following CSS selector of this element:
  

```python
home_button3 = driver.find_element(By.CSS_SELECTOR, "body &gt; div &gt; a &gt; input")
home_button3.click()
driver.back()
```

]



]






---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.TAG_NAME, "")`


.panelset[
.panel[.panel-name[(1)]
- `find_element(By.TAG_NAME, "")` &amp; `find_elements(By.TAG_NAME, "")`:
  - Return element(s) that are found by the specified tag. 

]

.panel[.panel-name[(2)]

.pull-left[
- The following example page displays a table which has several form fields to fill in.
  -  Each form field name is implemented using an `&lt;th&gt;` or table header cell tag inside a `&lt;tr&gt;` or table row tag:

]

.pull-right[

&lt;img src="lec_figs/find_tag1.png" width="100%" style="display: block; margin: auto;" /&gt;
]



]


.panel[.panel-name[(3)]
- Here is an example that uses the `find_element(By.TAG_NAME, "")` method to find the head of the table.



```python
table01 = driver.find_element(By.ID, "table01")
thead = table01.find_element(By.TAG_NAME, "thead")
thead.text
```


]

]






---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.LINK_TEXT, "")`

.panelset[
.panel[.panel-name[(1)]
- `find_element(By.LINK_TEXT, "")` &amp; `find_elements(By.LINK_TEXT, "")`:
  - Find link(s) using the text displayed for the link. 

]

.panel[.panel-name[(2)]
- For example, we may want to get the **Selenium** displayed on the example site. 
  - Here is the HTML code for the **Selenium** implemented as the `&lt;a&gt;`, or anchor tag, with text **"Selenium"**:



```html
&lt;a href="http://www.selenium.dev/"&gt;Selenium&lt;/a&gt;
```

]


.panel[.panel-name[(3)]
-  Here is an example that uses the `find_element(By.LINK_TEXT, "")` method to find **Selenium**.



```python
selenium_link = driver.find_element(By.LINK_TEXT, "Selenium")
selenium_link.click()
```


]

]



---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.PARTIAL_LINK_TEXT, "")`


.panelset[
.panel[.panel-name[(1)]
- Sometimes, there can be several link texts that contain a common word in the webpage.


- `find_element(By.PARTIAL_LINK_TEXT, "")` &amp; `find_elements(By.PARTIAL_LINK_TEXT, "")`:
  - Find link(s) using partial text. 


]

.panel[.panel-name[(2)]
- Let us use this method to find these links using the `"qav"` text and check whether we have two of these links available on the page.


```python
Selen_links = driver.find_elements(By.PARTIAL_LINK_TEXT, "qav")
print(len(Selen_links))
Selen_links[0].click()
driver.back()
```
]


]


---
# Locating Web Elements by `find_element()`
### &lt;p style="color:#00449E"&gt; `find_element(By.XPATH, "")`

.panelset[
.panel[.panel-name[(1)]
- `find_element(By.XPATH, "")` &amp; `find_element(By.XPATH, "")`:
  - Return element(s) that are found by the specified XPath query. 


- XPath is a query language used to search and locate nodes in a XML document.
  - All major web browsers support XPath. 
  - Selenium can leverage and use powerful XPath queries to find elements on a web page. 
  - One of the advantages of using XPath is when we can’t find a suitable ID, name, or class attribute value for the element. 

]

.panel[.panel-name[(2)]
- We can use *XPath* to either find the element in absolute terms or relative to an element that does have an ID or name attribute.


- We can also use defined attributes other than the ID, name, or class with *XPath* queries. 


]


.panel[.panel-name[(3)]

- For example, we want to get the second table. 

  - The body of this table consists of a series of `&lt;tr&gt;` tags, but does not have the ID, name, or class attributes defined.
  
  - Also, we cannot use the `find_element(By.TAG_NAME, "")` method as there are multiple `&lt;tr&gt;` and `&lt;th&gt;` tags defined on the page.
]


.panel[.panel-name[(4)]

- To find the XPath of this element, we `Inspect` the example site, in the Elements window, move the cursor over its DOM structure and find the desired element. 

  - We then right-click and choose copy XPath from the pop-up menu. 
  
  - We obtain the following XPath of the first row and the first column of the table body:



```html
//*[@id="table02"]/tbody/tr[1]/td[1]
```

]


.panel[.panel-name[(5)]
- We then pass this XPath to the `find_element(By.XPATH, "")` method as an argument:
  - Find the XPath for "Tiger Nixon" in the second table.


```python
elt = driver.find_element(By.XPATH, '//*[@id="table02"]/tbody/tr[1]/td[1]')
elt.text
```

]

.panel[.panel-name[(6)]
- We typically use the XPath method when there exists an element with a unique id on the path to the desired element. 
  - Otherwise, this method is not reliable.


]

]



---
class: inverse, center, middle

# Filling in Web Forms
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;



---
# Filling in Web Forms
### &lt;p style="color:#00449E"&gt; 
.panelset[
.panel[.panel-name[(1)]
- Web forms are ubiquitous when surfing the internet. 


- A web form comprises web elements such as input boxes, check boxes, radio buttons, links, drop down menus, and submit buttons to collect user data. 


&lt;img src="lec_figs/webform.png" width="50%" style="display: block; margin: auto;" /&gt;


]

.panel[.panel-name[(2)]
-  To process web forms, we need to first find these web elements and then take subsequent actions on them like selecting a value or entering some text. 


- Selenium performs actions on the web form and interacts with the form.
]
]

---
# Filling in web forms
### &lt;p style="color:#00449E"&gt; Input box
.panelset[
.panel[.panel-name[(1)]
- To handle any input box, we must be able to enter information, clear information or get information from the box. 
  -  To enter text into an input box we can use the `send_keys()` method. 


```python
driver.find_element(By.ID, 'username').send_keys("YOUR_NAME")
```


]
.panel[.panel-name[(2)]
- If we need to validate some existing text, we can fetch text already in a text box using the `get_attribute()` method:


```python
nameText = driver.find_element(By.ID, 'username').get_attribute("value")
```



]

.panel[.panel-name[(3)]
- To clear pre-entered text, we can use the `clear()` method. 


```python
driver.find_element(By.ID, 'username').clear()
```


]


]


---
# Filling in web forms
### &lt;p style="color:#00449E"&gt; Dropdown

.panelset[
.panel[.panel-name[(1)]
- A dropdown provides a list of options to the user, thereby giving access to one or multiple values as per the requirement.

-  The Selenium Python API provides the `Select` class, which allows us to select the element of our choice from a dropdown menu. 

- Note that the `Select` class only works with tags that have `&lt;select&gt;` tags. 


]
.panel[.panel-name[(2)]
- We can select a sub-element of the dropdown using:
  1. `index`; 
  2. `value`;
  3. `text`.



```python
from selenium.webdriver.support.ui import Select
gender_dropdown = Select(driver.find_element(By.NAME, "sgender"))
gender_dropdown.select_by_index(2)
gender_dropdown.select_by_value("female")
gender_dropdown.select_by_visible_text("Male")
```


]

.panel[.panel-name[(3)]

- In a similar way, we can deselect any selected value from the dropdown using any of the following options: 
  1. `deselect_by_index()` 
  2. `deselect_by_value`
  3. `deselect_by_visible_text` 

]


]



---
# Filling in web forms
### &lt;p style="color:#00449E"&gt; Radio button

.panelset[
.panel[.panel-name[(1)]

- A radio button is a circular element on the screen that we can select.
  - It is only possible to select one radio button out of several choices by the `click()` method.


]
.panel[.panel-name[is_selected()]
- To get the current state of the radio button we can use one of two methods: `is_selected()` or `get_attribute("checked")`


```python
driver.find_element(By.XPATH, '//*[@id="container"]/div[8]/input[1]').click()
yr_exp_boolean = driver.find_element(By.XPATH, '//*[@id="container"]/div[8]/input[1]').is_selected()
print(yr_exp_boolean)
print(type(yr_exp_boolean))
```

]

.panel[.panel-name[get_attribute("checked")]


```python
yr_exp_boolean2 = driver.find_element(By.XPATH, '//*[@id="container"]/div[8]/input[1]').get_attribute("checked")
print(yr_exp_boolean2)
print(type(yr_exp_boolean2))
```


]


]


---
# Filling in web forms
### &lt;p style="color:#00449E"&gt; Check box
.panelset[
.panel[.panel-name[(1)]

- To select or check a value in a check box we use the `click()` method. 
  - To get the current state of the check box we can use one of two methods: `is_selected()` or `get_attribute("checked")`
  - It is also possible to de-select check boxes.


]
.panel[.panel-name[is_selected()]


```python
driver.find_element(By.XPATH, '/html/body/form/fieldset/div/div/div[9]/input[1]').click()
skills_boolean = driver.find_element(By.XPATH, '/html/body/form/fieldset/div/div/div[9]/input[1]').is_selected()
print(skills_boolean)
print(type(skills_boolean))
```


]


.panel[.panel-name[get_attribute("checked")]


```python
skills_boolean = driver.find_element(By.XPATH, '/html/body/form/fieldset/div/div/div[9]/input[4]').get_attribute("checked")
print(skills_boolean)
print(type(skills_boolean))
```


]

]


---
# Filling in web forms
### &lt;p style="color:#00449E"&gt; Button


- Buttons are simply used to submit whatever information we have filled in our forms to the server. 
  - This can be done through click actions on the button, mostly using the `click()` method:


```python
driver.find_element(By.ID, "submit").click()
```



---
class: inverse, center, middle

# NoSuchElementException and WebDriverWait
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;



---
# NoSuchElementException
### &lt;p style="color:#00449E"&gt; 

- When a web element is not found, it throws the `NoSuchElementException`.
  - `try-except` can be used to avoid the termination of the selenium code.



```python
from selenium.common.exceptions import NoSuchElementException
try:
    elem = driver.find_element(By.XPATH, "element_xpath")
    elem.click()
except NoSuchElementException:
    pass
```


- This solution is to address the **inconsistency** in the DOM among the seemingly same pages.



---
# NoSuchElementException
### &lt;p style="color:#00449E"&gt; `execute_script()`
.panelset[
.panel[.panel-name[(1)]

- When the page loads, for some reason we may be taken to the bottom of the page, but the element we need to scrape is on the top of the page and thus is out of view.

- In this situation, we can locate the element in the DOM first, then use the `execute_script()` method to scroll the element into view:




```python
elem = driver.find_element(By.XPATH, "element_xpath")
driver.execute_script("arguments[0].scrollIntoView();", elem)
```


]
.panel[.panel-name[(2)]

- In case the element has the attribute `style="display: none;"`, remove the attribute through `execute_script()` method:



```python
elem = driver.find_element(By.XPATH, "element_xpath")
driver.execute_script("arguments[0].removeAttribute('style')", elem)
elem.send_keys("text_to_send")
```


]


]

---
# WebDriverWait
### &lt;p style="color:#00449E"&gt; `WebDriverWait` with `expected_conditions`
.panelset[
.panel[.panel-name[(1)]
- If the element is not present/visible in the HTML DOM immediately, induce `WebDriverWait` with `expected_conditions` set to the proper method as follows:

- To wait for `presence_of_element_located`:


```python
element = WebDriverWait(driver, 10).until(expected_conditions.presence_of_element_located((By.XPATH, "element_xpath"))) # 10 is timeout in seconds when an expectation is called
```

]

.panel[.panel-name[(2)]
- To wait for `visibility_of_element_located`:


```python
element = WebDriverWait(driver, 20).until(expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, "element_css")))
```



]

.panel[.panel-name[(3)]
- To wait for `element_to_be_clickable`:


```python
element = WebDriverWait(driver, 20).until(expected_conditions.element_to_be_clickable((By.LINK_TEXT, "element_link_text")))
```



]


]

---
# WebDriverWait
### &lt;p style="color:#00449E"&gt; `WebDriverWait` with `expected_conditions`

-  The `time.sleep()` method is an explicit wait to set the condition to be an exact time period to wait:


```python
import time

driver.find_element(By.XPATH, '//*[@id="one"]/input').click()
time.sleep(5)
element = driver.find_element(By.XPATH, '//*[@id="two"]')
element.text
```

- A more efficient solution than `time.sleep()` would be to make `WebDriver()` wait only as long as required. 



---
# # WebDriverWait
### &lt;p style="color:#00449E"&gt; `WebDriverWait` with `expected_conditions`

- Implicit wait with `implicitly_wait()` directs the `WebDriver` to wait for a certain measure of time before throwing an exception. 

- Once this time is set, `WebDriver` will wait for the element before the exception occurs.



```python
driver.find_element(By.XPATH, '//*[@id="one"]/input').click()
driver.implicitly_wait(5)
element2 = driver.find_element(By.XPATH, '//*[@id="two"]')
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!--Hat-tip: https://www.garrickadenbuie.com/blog/xaringan-tip-logo-all-slides/-->
<style>
.logo {
  background-image: url(img/logo-blue.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 66px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
