<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 15</title>
    <meta charset="utf-8" />
    <meta name="author" content="Byeong-Hak Choe" />
    <meta name="date" content="2022-10-20" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/tile-view-0.2.6/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view-0.2.6/tile-view.js"></script>
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <script src="libs/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <script src="libs/xaringanExtra-webcam-0.0.1/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <script src="libs/js-cookie-3.0.0/js.cookie.js"></script>
    <script src="libs/peerjs-1.3.1/peerjs.min.js"></script>
    <script src="libs/tiny.toast-1.0.0/toast.min.js"></script>
    <link href="libs/xaringanExtra-broadcast-0.2.6/broadcast.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-broadcast-0.2.6/broadcast.js"></script>
    <link href="libs/shareon-1.4.1/shareon.min.css" rel="stylesheet" />
    <script src="libs/shareon-1.4.1/shareon.min.js"></script>
    <link href="libs/xaringanExtra-shareagain-0.2.6/shareagain.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-shareagain-0.2.6/shareagain.js"></script>
    <link href="libs/xaringanExtra-extra-styles-0.2.6/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/nhsr.css" type="text/css" />
    <link rel="stylesheet" href="css/nhsr-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, bottom

# Lecture 15
----
## **DANL 100: Programming for Data Analytics**
### Byeong-Hak Choe
### October 20, 2022


---
# Exam Policies
During the exam, ...
- Students can read any books, paper sheets, PDF files on PDF reader apps, Python Scripts or text files on Spyder.
  - Students are not allowed to use other apps, for example, Google Docs, Google Sheets, Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Numbers, Pages, Keynotes, Notes.
- Students can visit (1) the class website (https://bcdanl.github.io) and (2) the Canvas website for the course.
  - Students are not allowed to visit any other websites, such as Google, Stack Overflow, and Gmail.
- Students can communicate with Byeong-Hak Choe.
  - Students are not allowed to communicate with other students.



---
class: inverse, center, middle

# Dictionaries and Sets
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;



---
# Dictionaries

- A *dictionary* is similar to a list, but the order of items doesn't matter, and they aren't selected by an offset such as 0 or 1.

  - Instead, we specify a unique *key* to associate with each value.

  - This *key* is often a string, but it can actually be any of Python's immutable types: boolean, integer, float, tuple, string, and others.

- Dictionaries are mutable, so we can add, delete, and change their key-value elements.

---
# Dictionaries
### &lt;p style="color:#00449E"&gt; Create with `dict()` &lt;/p&gt;

- We can also create a dictionary by passing named arguments and values to the `dict()` function.


```python
acme_customer = {'first': 'Wile', 'middle': 'E', 'last': 'Coyote'}
acme_customer

acme_customer = dict(first = "Wile", middle = "E", last = "Coyote")
acme_customer
```

- The argument names in `dict()` need to be legal variable names (no spaces, no reserved words):


```python
x = dict(name="Elmer", def="hunter")
```

---
# Dictionaries
### &lt;p style="color:#00449E"&gt; Convert with `dict()` &lt;/p&gt;

- We can use `dict()` to convert two-value sequences into a dictionary.
  - We might run into such key-value sequences at times, such as "Geneseo, 20, Brockport, 14." 
  - The first item in each sequence is used as the key and the second as the value.


.panelset[
.panel[.panel-name[lol]
- *lol* (a list of two-item lists):


```python
lol = [ ['a', 'b'], ['c', 'd'], ['e', 'f'] ]
dict(lol)
```
]

.panel[.panel-name[lot]
- *lot* (a list of two-item tuples):


```python
lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ]
dict(lot)
```
]

.panel[.panel-name[tol]
- *tol* (a tuple of two-item lists):


```python
tol = ( ['a', 'b'], ['c', 'd'], ['e', 'f'] )
dict(tol)
```
]

.panel[.panel-name[los]
- *los* (a list of two-character strings):


```python
los = [ 'ab', 'cd', 'ef' ]
dict(los)
```
]

.panel[.panel-name[tos]
- *tos* (a tuple of two-character strings):


```python
tos = ( 'ab', 'cd', 'ef' )
dict(tos)
```
]

]




---
# Dictionaries
### &lt;p style="color:#00449E"&gt; Add or Change an Item by `[ key ]` &lt;/p&gt;


.panelset[
.panel[.panel-name[st_city]
- Let's make a dictionary of some pairs of US cities and states, using their states as *keys* and city names as *values*:


```python
st_city = {
  'MN': 'Rochester',
  'WY': 'Laramie',
  'CO': 'Denver'
  }
st_city
```
]

.panel[.panel-name[Rocjester]
- Here, we want to add Rochester, NY.
  - Here's an attempt to add it, but it spelled wrong:


```python
st_city['NY'] = 'Rocjester'
st_city
```
]

.panel[.panel-name[Rochester]
- Here's some repair code:


```python
st_city['NY'] = 'Rochester'
st_city
```
]

.panel[.panel-name[city_st]
-  Remember that dictionary keys must be unique. 
  - That's why we used state names for keys instead of city names.
  - If we use a key more than once, the last value wins:

```python
city_st = {
  'Rochester': 'MN',
  'Laramie': 'WY',
  'Denver': 'CO',
  'Rochester': 'NY'
  }
city_st
```
]

]




---
# Dictionaries
### &lt;p style="color:#00449E"&gt; Get an Item by `[key]` or with `get()` &lt;/p&gt;

.panelset[
.panel[.panel-name[`[key]`]
- We specify the dictionary and key to get the corresponding value: 

```python
city_st = {
  'Rochester': 'MN',
  'Laramie': 'WY',
  'Denver': 'CO',
  'Rochester': 'NY'
  }
city_st['Denver']
```
]

.panel[.panel-name[`[key]`]
- If the key is not present in the dictionary, we'll get an exception:

```python
city_st['Buffalo']
```

- There are two good ways to avoid this: `in` and `get()`
]

.panel[.panel-name[`in`]
- Test for the key at the outset by using `in`:

```python
'Buffalo' in city_st
```
]
.panel[.panel-name[`get()`]
- Use the special dictionary `get()` function.
  - If the key exists, we get its value:

```python
city_st.get('Denver')
```
]

.panel[.panel-name[`get()`]
- Use the special dictionary `get()` function.
  - If the key does not exist and the optional value is provided, we get the optional value:

```python
city_st.get('Buffalo', 'Not in city_st')
```
]


.panel[.panel-name[`get()`]
- Use the special dictionary `get()` function.
  - If the key does not exist and the optional value is not provided, we get `None`, which displays nothing in the console.

```python
city_st.get('Buffalo')
```
]

]





---
# Dictionaries

.panelset[
.panel[.panel-name[`keys()`]
### &lt;p style="color:#00449E"&gt; Get All Keys with `keys()` &lt;/p&gt;

- We can use `keys()` to get all of the keys in a dictionary. 

```python
signals = {'green': 'go', 
           'yellow': 'go faster', 
           'red': 'smile for the camera'}
signals.keys()
list( signals.keys() )   # to turn the result into a list object.
```
]

.panel[.panel-name[`values()`]
### &lt;p style="color:#00449E"&gt; Get All Values with values() &lt;/p&gt;

- To obtain all the values in a dictionary, use `values()`:

```python
signals = {'green': 'go', 
           'yellow': 'go faster', 
           'red': 'smile for the camera'}
signals.values()
list( signals.values() )   # to turn the result into a list object.
```
]

.panel[.panel-name[`items()`]
### &lt;p style="color:#00449E"&gt; Get All Key-Value Pairs with `items()` &lt;/p&gt;

- When we want to get all the key-value pairs from a dictionary, use the `items()` function:

```python
signals = {'green': 'go', 
           'yellow': 'go faster', 
           'red': 'smile for the camera'}
signals.items()
list( signals.items() )   # to turn the result into a list object.
```
]


.panel[.panel-name[`items()`]
### &lt;p style="color:#00449E"&gt; Get Length with `len()` &lt;/p&gt;

- Count your key-value pairs:

```python
signals = {'green': 'go', 
           'yellow': 'go faster', 
           'red': 'smile for the camera'}
len(signals)
```
]



.panel[.panel-name[{**a, **b}]
### &lt;p style="color:#00449E"&gt; Combine Dictionaries with `{**a, **b}` &lt;/p&gt;

- Starting with Python 3.5, there's a new way to merge dictionaries, using the `**`:

```python
first = {'a': 'agony', 'b': 'bliss'}
second = {'b': 'bagels', 'c': 'candy'}
{**first, **second}

third = {'d': 'donuts'}
{**first, **third, **second}
```
]

.panel[.panel-name[`update()`]
### &lt;p style="color:#00449E"&gt; Combine Dictionaries with `update()` &lt;/p&gt;

- We can use the `update()` function to copy the keys and values of one dictionary into another.
  - Let's update `st_city` with `other_city`

```python
st_city = { 'MN': 'Rochester',
            'WY': 'Laramie',
            'CO': 'Denver',
            'NY': 'Rochester' }
  
other_city = {'MA': 'Boston'}
st_city.update(other_city)
```
]

.panel[.panel-name[`update()`]
### &lt;p style="color:#00449E"&gt; Combine Dictionaries with `update()` &lt;/p&gt;

- What happens if the second dictionary has the same key as the dictionary into which it's being merged?

```python
first = {'a': 1, 'b': 2}
second = {'b': 'platypus'}
first.update(second)
first
```
]

]




---
# Dictionaries
.panelset[

.panel[.panel-name[`for`]
### &lt;p style="color:#00449E"&gt; Iterate with `for` and `in` &lt;/p&gt;
- Iterating over a dictionary (or its `keys()` function) returns the keys. 


```python
accusation = {'room': 'ballroom', 
              'weapon': 'lead pipe',
              'person': 'Col. Mustard'}
for card in accusation: # or, for card in accusation.keys():
    print(card)
```

]




.panel[.panel-name[`values()`]
### &lt;p style="color:#00449E"&gt; Iterate with `for` and `in` &lt;/p&gt;
- To iterate over the values rather than the keys, we use the dictionary's `values()` function:



```python
accusation = {'room': 'ballroom', 
              'weapon': 'lead pipe',
              'person': 'Col. Mustard'}
for value in accusation.values():
    print(value)
```

]


.panel[.panel-name[`items()`]
### &lt;p style="color:#00449E"&gt; Iterate with `for` and `in` &lt;/p&gt;
- To return both the key and value as a tuple, we can use the `items()` function:



```python
accusation = {'room': 'ballroom', 
              'weapon': 'lead pipe',
              'person': 'Col. Mustard'}
for item in accusation.items():
    print(item)
```

]
.panel[.panel-name[`items()`]
### &lt;p style="color:#00449E"&gt; Iterate with `for` and `in` &lt;/p&gt;
- For each tuple returned by `items()`, let's assign the first value (the key) to *card*, and the second (the value) to *contents*:


```python
accusation = {'room': 'ballroom', 
              'weapon': 'lead pipe',
              'person': 'Col. Mustard'}
for card, contents in accusation.items():
    print('Card', card, 'has the contents', contents)
```

]


.panel[.panel-name[comprehensions]
### &lt;p style="color:#00449E"&gt; Dictionary Comprehensions &lt;/p&gt;
- Dictionaries also have comprehensions.
  - The simplest form of dictionary comprehension looks like this:

&lt;img src="../lec_figs/int-py-dict-comprehension.png" width="80%" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[comprehensions]
### &lt;p style="color:#00449E"&gt; Dictionary Comprehensions &lt;/p&gt;

- Let's run a loop over each of the seven letters in the string 'letters' and counting how many times that letter appears.


```python
word = 'letters'
letter_counts = {letter: word.count(letter) for letter in word}
letter_counts
```

- How many times do we count 't' here?
]


.panel[.panel-name[comprehensions w/ `set()`]
### &lt;p style="color:#00449E"&gt; Dictionary Comprehensions &lt;/p&gt;

- Let's run a loop over each of the seven letters in the string 'letters' and counting how many times that letter appears.


```python
word = 'letters'
letter_counts = {letter: word.count(letter) for letter in set(word)}
letter_counts
```

- How many times do we count 't' here?

]


.panel[.panel-name[comprehensions w/ if]
### &lt;p style="color:#00449E"&gt; Dictionary Comprehensions &lt;/p&gt;
- Dictionary comprehensions can also have *if* tests and multiple *for* clauses:

&lt;img src="../lec_figs/int-py-dict-comprehension-if.png" width="95%" style="display: block; margin: auto;" /&gt;


```python
vowels = 'aeiou'
word = 'onomatopoeia'
vowel_counts = {letter: word.count(letter) for letter in set(word) 
                                           if letter in vowels}
vowel_counts
```

]

]



---
# Sets
- A set is like a dictionary with its values thrown away, leaving only the keys.

  - As with a dictionary, each key must be unique.



- We use a set when we only want to know that something exists, and nothing else about it.

  - Use a dictionary if we want to attach some information to the key as a value.


---
# Sets
### &lt;p style="color:#00449E"&gt; Common things to do with sets &lt;/p&gt;
  
&lt;img src="../lec_figs/int-py-fig8-1.png" width="55%" style="display: block; margin: auto;" /&gt;

- The null or empty set is a set with zero elements.

---
# Sets

.panelset[
.panel[.panel-name[`set()`]
### &lt;p style="color:#00449E"&gt; Create with `set()` &lt;/p&gt;
- To create a set, we use the `set()` function or enclose one or more comma-separated values in curly brackets:

```python
empty_set = set()
empty_set

even_numbers = {0, 2, 4, 6, 8}
even_numbers

odd_numbers = {1, 3, 5, 7, 9}
odd_numbers
```
]


.panel[.panel-name[`set()`]
### &lt;p style="color:#00449E"&gt; Convert with `set()` &lt;/p&gt;
- We can create a set from a list, string, tuple, or dictionary, discarding any duplicate values.

```python
set( 'letters' )   
set( ['Dasher', 'Dancer', 'Prancer', 'Mason-Dixon'] )
set( ('Ummagumma', 'Echoes', 'Atom Heart Mother') )
set( {'apple': 'red', 'orange': 'orange', 'cherry': 'red'} )
```
- Sets are unordered.


]

.panel[.panel-name[`for`]
### &lt;p style="color:#00449E"&gt; Iterate with `for` and `in` &lt;/p&gt;
- We can iterate over all items in a set:

```python
furniture = set(('sofa', 'ottoman', 'table'))
for piece in furniture:
    print(piece)
```
]

]

---
# Sets
### &lt;p style="color:#00449E"&gt; Test for a Value with `in` &lt;/p&gt;

.panelset[
.panel[.panel-name[`drinks`]

- Here is a dictionary called `drinks`. 
  - Each key is the name of a mixed drink, and the corresponding value is a set of that drink's ingredients:
  - A set is just a bunch of *values*, and a dictionary contains *key : value* pairs.

```python
drinks = {  'martini': {'vodka', 'vermouth'},
            'black russian': {'vodka', 'kahlua'},
            'white russian': {'cream', 'kahlua', 'vodka'},
            'manhattan': {'rye', 'vermouth', 'bitters'},
            'screwdriver': {'orange juice', 'vodka'}   }
```
]

.panel[.panel-name[`vodka`]

- Print drinks that contain vodka:

```python
for name, contents in drinks.items():
    if 'vodka' in contents:
        print(name)
```
]


.panel[.panel-name[`vodka`]

- Print drinks that neither contain either `cream` nor `vermouth` but do `vodka`:

```python
for name, contents in drinks.items():
    if 'vodka' in contents \
        and not ('vermouth' in contents or 'cream' in contents):
        print(name)
```
]

]

---
# Sets
### &lt;p style="color:#00449E"&gt; Combinations and Operators &lt;/p&gt;

.panelset[
.panel[.panel-name[`drinks`]

- Here are some examples to consider for set combinations and operations.

```python
drinks = {  'martini': {'vodka', 'vermouth'},
            'black russian': {'vodka', 'kahlua'},
            'white russian': {'cream', 'kahlua', 'vodka'}  }
bruss = drinks['black russian']
wruss = drinks['white russian']
a = {1, 2}
b = {2, 3}
```
]


.panel[.panel-name[intersection]
- We get the intersection (members common to both sets) with the
special punctuation symbol `&amp;`. 
  - The set `intersection()` function does the same.

```python
a &amp; b
a.intersection(b)

bruss &amp; wruss
```

]

.panel[.panel-name[union]
- Let's get the union (members of either set) by using `|` or the set `union()` function:


```python
a | b
a.union(b)

bruss | wruss
```

]
.panel[.panel-name[difference]
- The difference (members of the first set but not the second) is obtained by using the character `-` or the `difference()` function:


```python
a - b
a.difference(b)

bruss - wruss
wruss - bruss
```

]

.panel[.panel-name[exclusive]
- The *exclusive* or (items in one set or the other, but not both) uses `^` or `symmetric_difference()`:


```python
a ^ b
a.symmetric_difference(b)

bruss ^ wruss
```

]

.panel[.panel-name[subset]
- We can check whether one set is a subset of another (all members of the first set are also in the second set) by using `&lt;=` or `issubset()`:


```python
a &lt;= b
a.issubset(b)

bruss &lt;= wruss

a &lt;= a   # any set is a subset of itself?
a.issubset(a)
```

]



.panel[.panel-name[subset]
- To be a *proper subset*, the second set needs to have all the members of the first and more. 
  - Calculate it by using `&lt;`:


```python
a &lt; b
b &lt; a

bruss &lt; wruss
```

]



.panel[.panel-name[superset]
- A *superset* is the opposite of a subset (all members of the second set are also members of the first). This uses `&gt;=` or `issuperset()`:


```python
a &gt;= b
a.issuperset(b)

wruss &gt;= bruss

a &gt;= a   # any set is a superset of itself?
a.issuperset(a)
```

]


.panel[.panel-name[superset]
- To be a *proper superset*, the first set needs to have all the members of the second and more. 
  - Calculate it by using `&gt;`:


```python
a &gt; b

wruss &gt; bruss

a &gt; a 
```

]


.panel[.panel-name[combinations]

- What if we want to check for combinations of set values?
  - Suppose that we want to find any drink that has orange juice or vermouth.
  - Let's use the *set intersection operator*, which is an ampersand (`&amp;`):
  

```python
for name, contents in drinks.items():
    if contents &amp; {'vermouth', 'orange juice'}:
        print(name)
```

]

.panel[.panel-name[combinations]
- Let's rewrite the example from the previous section, in which we wanted vodka but neither cream nor vermouth:


```python
for name, contents in drinks.items():
    if 'vodka' in contents and not contents &amp; {'vermouth', 'cream'}:
        print(name)
```

]


]



---
# Sets

.panelset[
.panel[.panel-name[comprehensions]
### &lt;p style="color:#00449E"&gt; Set Comprehensions &lt;/p&gt;

- Sets also have comprehensions:

&lt;img src="../lec_figs/int-py-set-comprehension.png" width="66%" style="display: block; margin: auto;" /&gt;

&lt;img src="../lec_figs/int-py-set-comprehension-if.png" width="83%" style="display: block; margin: auto;" /&gt;



```python
a_set = {number for number in range(1,6) if number % 3 == 1}
```

]

.panel[.panel-name[`frozenset()`]
### &lt;p style="color:#00449E"&gt; Create an Immutable Set with `frozenset()` &lt;/p&gt;

- If we want to create a set that can't be changed, call the `frozenset()` function with any iterable argument:

```python
frozenset([3, 2, 1])
frozenset(set([2, 1, 3]))
frozenset({3, 1, 2})
frozenset( (2, 3, 1) )

fs = frozenset([3, 2, 1])
fs
fs.add(4)
```

]


]


---
# Make Bigger Data Structures

.panelset[
.panel[.panel-name[bigger data structures]
- We worked up from simple booleans, numbers, and strings to lists, tuples, sets, and dictionaries. 
- We can combine these built-in data structures into bigger, more complex structures of our own. 

- Let's start with three different lists:

```python
newyork = ['Geneseo', 'Rochester', 'Buffalo']
california = ['San Francisco', 'Los Angeles', 'San Diego']
texas = ['Dallas', 'Houston', 'Austin']
```

]

.panel[.panel-name[tuple_of_lists]
- We can make a tuple that contains each list as an element:

```python
tuple_of_lists = newyork, california, texas
tuple_of_lists
```


]
.panel[.panel-name[list_of_lists]
- We can make a list that contains the three lists:

```python
list_of_lists = [newyork, california, texas]
list_of_lists
```


]
.panel[.panel-name[dict_of_lists]
- Finally, let's create a dictionary of lists. 
  - In this example, let's use the abbreviated name of the state as the key and the list of cities as the value:

```python
dict_of_lists = {'NY': newyork, 'CA': california, 'TX': texas}
dict_of_lists
```


]

]


---
# Dictionaries and Sets
### &lt;p style="color:#00449E"&gt; Class Exercises &lt;/p&gt;
*1*. Make an English-to-French dictionary called `e2f` and print it. Here are your starter words: `dog` is `chien`, `cat` is `chat`, and `walrus` is `morse`.

*2*. Using your three-word dictionary `e2f`, print the French word for `walrus`.

*3*. Make a French-to-English dictionary called `f2e` from `e2f` Use the `items` method.

*4*. Print the English equivalent of the French word `chien`.

*5*. Print the set of English words from `e2f`.



---
# Dictionaries and Sets
### &lt;p style="color:#00449E"&gt; Class Exercises &lt;/p&gt;
*6*. Make a multilevel dictionary called `life`. Use these strings for the topmost keys: '`animals`', '`plants`', and '`other`'. Make the 'animals' key refer to another dictionary with the keys '`cats`', '`octopi`', and '`emus`'. Make the '`cats`' key refer to a list of strings with the values '`Henri`', '`Grumpy`', and '`Lucy`'. Make all the other keys refer to empty dictionaries.

*7*. Print the top-level keys of `life`.

*8*. Print the keys for `life['animals']`.

*9*. Print the values for `life['animals']['cats']`.


---
# Dictionaries and Sets
### &lt;p style="color:#00449E"&gt; Class Exercises &lt;/p&gt;
*10*. Use a dictionary comprehension to create the dictionary `squares`. Use `range(10)` to return the keys, and use the square of each key as its value.

*11*. Use a set comprehension to create the set `odd` from the odd numbers in `range(10)`.





---
class: inverse, center, middle

# Functions
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---
# Functions


- So far, all of our Python code examples have been little fragments. 
  - These are good for small tasks, but no one wants to retype fragments all the time. 
  - We need some way of organizing larger code into manageable pieces.
  
  
- The first step to code reuse is the *function*: a named piece of code, separate from all others. 


- A function can take any number and type of input *parameters* and return any
number and type of output *results*.


- We can do two things with a function:
  - *Define* it, with zero or more parameters
  - *Call* it, and get zero or more results


---
# Functions
### &lt;p style="color:#00449E"&gt; Define a Function with `def` &lt;/p&gt;


.panelset[
.panel[.panel-name[`def`]
- To define a Python function, we type `def`, the function name, parentheses enclosing any input *parameters* to the function, and then finally, a colon (:). 

- Function names have the same rules as variable names (they must start with a letter or _ and contain only letters, numbers, or _).
]

.panel[.panel-name[(1) def]
- Let's define a very simple function that has no parameters.

```python
def do_nothing():
    pass      # indention is needed here
```

- We use the `pass` statement when we want Python to do nothing.
  - It's the equivalent of *This page intentionally left blank.*

]

.panel[.panel-name[(1) call]
- We call the `do_nothing()` function just by typing its name and parentheses. 

```python
do_nothing()
```
]

]

---
# Functions
### &lt;p style="color:#00449E"&gt; Call a Function with Parentheses &lt;/p&gt;


.panelset[
.panel[.panel-name[(2)]
- Let's define and call another function that has no parameters but prints a single word:


```python
def make_a_sound():
    print('quack')  

make_a_sound()
```

- When we called this function, Python ran the code inside its definition.
  - In this case, it printed a single word and returned to the main program.

]  

.panel[.panel-name[(3) `def` with `return`]
- Let's try a function that has no parameters but *returns* a value:

```python
def agree():
    return True
```
]


.panel[.panel-name[(3) call]
- We can call the `agree()` function and test its returned value by using `if`:

```python
if agree():
    print('Splendid!')
else:
    print('That was unexpected.')
```

]

]


---
# Functions
### &lt;p style="color:#00449E"&gt; Arguments and Parameters &lt;/p&gt;
- Let's define the function `echo()` with one parameter called `anything`.
  - It uses the `return` statement to send the value of anything back to its caller twice, with a space between:


```python
def echo(anything):
    return anything + ' ' + anything
  
echo('Geneseo')
```

- The values we pass into the function when we call it are known as *arguments*. 

- When we call a function with arguments, the values of those arguments are copied to their corresponding *parameters* inside the function.



---
# Functions
### &lt;p style="color:#00449E"&gt; Arguments and Parameters &lt;/p&gt;


```python
def echo(anything):
    return anything + ' ' + anything
  
echo('Geneseo')
```

- The function `echo()` was called with the argument string `'Geneseo'`. 

  - The value `'Geneseo'` was copied within `echo()` to the parameter `anything`, and then returned (in this case doubled, with a space) to the caller.
  
  

---
# Functions
### &lt;p style="color:#00449E"&gt; Arguments and Parameters &lt;/p&gt;

- Let's write a function that takes an input argument and actually does something with it. 
  - Call it `commentary`, have it take an input string parameter
called `color`, and make it *return* the string description to its caller:


```python
def commentary(color):   
    if color == 'red':
        return "It's a tomato."
    elif color == "green":
        return "It's a green pepper."
    elif color == 'bee purple':
        return "I don't know what it is, but only bees can see it."
    else:
        return "I've never heard of the color " + color + "."
```

  

---
# Functions
### &lt;p style="color:#00449E"&gt; Arguments and Parameters &lt;/p&gt;

.panelset[
.panel[.panel-name[call commentary('blue')]
- Call the function `commentary()` with the string argument `'blue'`.

```python
comment = commentary('blue')
```
- The function does the following:
  - Assigns the value `'blue'` to the function's internal color parameter
  - Runs through the `if-elif-else` logic chain
  - Returns a string
- The caller then assigns the string to the variable `comment`.
]

.panel[.panel-name[print(comment)]
- What did we get back?

```python
print(comment)
```

- A function can take any number of input arguments (including zero) of any type. 

- It can return any number of output results (also including zero) of any type. 
]

.panel[.panel-name[print(do_nothing())]
- If a function doesn't call `return` explicitly, the caller gets the result `None`.

```python
def do_nothing():
    pass
  
print(do_nothing())
```

]

]

---
# Functions
### &lt;p style="color:#00449E"&gt; `None` Is Useful &lt;/p&gt;


.panelset[
.panel[.panel-name[`None`]
- `None` is a special Python value that holds a place when there is nothing to say. 

  - It is not the same as the boolean value `False`, although it looks false when evaluated as a boolean. 
  

```python
thing = None
if thing:
    print("It's some thing")
else:
    print("It's no thing")
```
]

.panel[.panel-name[`is` `None`]
- To distinguish `None` from a boolean `False` value, use Python's `is` operator:

```python
thing = None
if thing is None:
    print("It's some thing")
else:
    print("It's no thing")
```
- We'll need `None` to distinguish a *missing* value from an *empty* value.
- Zero-valued numbers, empty strings (`''`), lists (`[]`), tuples (`(,)`), dictionaries (`{}`), and sets (`set()`) are all `False`, but are not the same as `None`.
]

.panel[.panel-name[`whatis(thing)`]
- Let's write a quick function that prints whether its argument is `None`, `True`, or `False`:

```python
def whatis(thing):
    if thing is None:
        print(thing, "is None")
    elif thing:
        print(thing, "is True")
    else:
        print(thing, "is False")
```
]

.panel[.panel-name[`whatis()`]
- Let's run some sanity tests:

```python
whatis(None)
whatis(True)
whatis(False)
```

]

.panel[.panel-name[`whatis()`]
- How about some real values?

```python
whatis(0)
whatis(0.0)
whatis('')
whatis("")
whatis('''''')
whatis(())
whatis([])
whatis({})
whatis(set())
```

]

.panel[.panel-name[`whatis()`]
- How about some real values?

```python
whatis(0.00001)
whatis([0])
whatis([''])
whatis(' ')
```

]

]


---
# Functions
.panelset[
.panel[.panel-name[Positional Arguments]
### &lt;p style="color:#00449E"&gt; Positional Arguments &lt;/p&gt;

- The most familiar types of arguments are positional arguments, whose values are copied to their corresponding parameters in order.

- This function builds a dictionary from its positional input arguments and returns it:

```python
def menu(wine, entree, dessert):
    return {'wine': wine, 'entree': entree, 'dessert': dessert}
  
menu('chardonnay', 'chicken', 'cake')
```
]

.panel[.panel-name[Positional Arguments]
### &lt;p style="color:#00449E"&gt; Positional Arguments &lt;/p&gt;

- A downside of positional arguments is that we need to remember the meaning of each position.

```python
menu('beef', 'bagel', 'bordeaux')
```
]


.panel[.panel-name[Keyword Arguments]

### &lt;p style="color:#00449E"&gt; Keyword Arguments &lt;/p&gt;
- To avoid positional argument confusion, we can specify arguments by the names of their corresponding parameters, even in a different order from their definition in the function:

```python
menu(entree='beef', dessert='bagel', wine='bordeaux')
# Specify the wine first, but use keyword arguments for the entree and dessert:
menu('frontenac', dessert='flan', entree='fish') 
```

- If we call a function with both positional and keyword arguments, the positional arguments need to come first.
]

]


---
# Functions
### &lt;p style="color:#00449E"&gt; Specify Default Parameter Values &lt;/p&gt;
.panelset[
.panel[.panel-name[default value for parameter]
- We can specify default values for parameters. 
  - The default is used if the caller does not provide a corresponding argument. 
  - Try calling `menu()` without the `dessert` argument:
  

```python
def menu(wine, entree, dessert='pudding'):
    return {'wine': wine, 'entree': entree, 'dessert': dessert}

menu('chardonnay', 'chicken') 
```

]

.panel[.panel-name[argument]
- We can specify default values for parameters. 
  - If we provide an argument, it's used instead of the default:
  

```python
def menu(wine, entree, dessert='pudding'):
    return {'wine': wine, 'entree': entree, 'dessert': dessert}

menu('dunkelfelder', 'duck', 'doughnut')
```

]

]



---
# Functions
### &lt;p style="color:#00449E"&gt; Specify Default Parameter Values &lt;/p&gt;
.panelset[
.panel[.panel-name[buggy(arg, result=[])]
- The `buggy()` function is expected to run each time with a fresh empty result list, add the arg argument to it, and then print a single-item list.

```python
def buggy(arg, result=[]):
    result.append(arg)
    print(result)
buggy('a')
buggy('b') # expect ['b']
```
- There's a bug: it's empty only the first time it's called. 
  - The second time, result still has one item from the previous call.
]


.panel[.panel-name[works(arg)]
- It would have worked if it had been written like this:

```python
def works(arg):
    result = []
    result.append(arg)
    return result
    
works('a')
works('b')
```
]

.panel[.panel-name[nonbuggy(arg, result=None)]
- The fix is to pass in something else to indicate the first call:

```python
def nonbuggy(arg, result=None):
    if result is None:
        result = []
    result.append(arg)
    print(result)
    
nonbuggy('a')
nonbuggy('b')
```
]

]



---
# Functions
### &lt;p style="color:#00449E"&gt; Explode/Gather Positional Arguments with `*` &lt;/p&gt;

.panelset[
.panel[.panel-name[(1)]
- When an asterisk (`*`) is used inside the function with a parameter, it groups a variable number of positional arguments into a single tuple of parameter values. 

```python
def print_args(*args):
    print('Positional tuple:', args)

print_args()
print_args(3, 2, 1, 'wait!', 'uh...')
```

&lt;!-- - In the following example, `args` is the parameter tuple that resulted from zero or more arguments that were passed to the function `print_args()`. --&gt;
&lt;!--   - Whatever we give, it will be printed as the `args` tuple: --&gt;
]


.panel[.panel-name[(2)]
- If our function has *required* positional arguments, as well, put them first; `*args` goes at the end and grabs all the rest:

```python
def print_more(required1, required2, *args):
    print('Need this one:', required1)
    print('Need this one too:', required2)
    print('All the rest:', args)

print_more('cap', 'gloves', 'scarf', 'monocle', 'mustache wax')
```

]

.panel[.panel-name[summary]
- We can pass positional argument to a function, which will match them inside to positional parameters. 

- We can pass a tuple argument to a function, and inside it will be a tuple parameter.

- We can pass positional arguments to a function, and gather them inside as the parameter `*args`, which resolves to the tuple args.
]

.panel[.panel-name[summary]
- We can also "explode" a tuple argument called `args` to positional parameters `*args` inside the function, which will be regathered inside into the tuple parameter `args`:

```python
def print_args(*args):
    print('Positional tuple:', args)

print_args(2, 5, 7, 'x')

args = (2,5,7,'x')
print_args(args)

print_args(*args)
```


]



.panel[.panel-name[summary]
- We can only use the `*` syntax in a function call or definition:

```python
*args
```

- Outside the function, `*args` explodes the tuple `args` into comma-separated positional parameters.

- Inside the function, `*args` gathers all of the positional arguments into a single args tuple.

]


]



---
# Functions
### &lt;p style="color:#00449E"&gt; Explode/Gather Positional Arguments with `**` &lt;/p&gt;

.panelset[
.panel[.panel-name[(1)]

- We can use two asterisks (`**`) to group keyword arguments into a dictionary, where the argument names are the keys, and their values are the corresponding dictionary values.


```python
def print_kwargs(**kwargs):
    print('Keyword arguments:', kwargs)

print_kwargs()
print_kwargs(wine='merlot', entree='mutton', dessert='macaroon')
```

- Inside the function, `kwargs` is a dictionary parameter.

]

.panel[.panel-name[summary]

- We can pass keyword arguments to a function, which will match them inside to keyword parameters. 

- We can pass a dictionary argument to a function, and inside it will be dictionary parameters. 

]


.panel[.panel-name[summary]

- We can pass one or more keyword arguments (*name=value*) to a function, and gather them inside as `**kwargs`, which resolves to the dictionary parameter called `kwargs`. 

- Outside a function, `**kwargs` explodes a dictionary `kwargs` into *name=value* arguments.

- Inside a function, `**kwargs` gathers *name=value* arguments into the single dictionary parameter `kwargs`.
]
]




---
# Functions
### &lt;p style="color:#00449E"&gt; Keyword-Only Arguments &lt;/p&gt;


.panelset[
.panel[.panel-name[keyword-only argument]

- *a keyword-only argument* is an argument that can only be provided as a keyword argument when a function is called.
  - It is recommended to be provided as *name=value*. 


```python
def print_data(data, *, start=0, end=100):
    for value in (data[start:end]):
        print(value)
```
- The single `*` in the definition above means that the parameters `start` and `end` must be provided as named arguments if we donâ€™t want their default values.
  
]

.panel[.panel-name[call with keyword-only argument]

```python
data = ['a', 'b', 'c', 'd', 'e', 'f']
print_data(data)
print_data(data, start=4)
print_data(data, end=2)
```
]

.panel[.panel-name[name only]



```python
def print_data2(data, *, start, end):
    for value in (data[start:end]):
        print(value)
print_data2(data)
print_data2(data, start=4)
print_data2(data, end=2)
print_data2(data, start = 2, end = 4)
```
- `start` and `end` are required arguments, because they doesn't have a default value and they must be specified as a keyword argument when we call the `print_data2()` function.

]


]


---
# Functions
### &lt;p style="color:#00449E"&gt; Mutable and Immutable Arguments &lt;/p&gt;

- Remember that if you assigned the same list to two variables, you could change it by using either one? And that you could not if the variables both referred to something like an integer or a string? 
  &lt;!-- - We need to watch for the same behavior when passing arguments to functions.  --&gt;
  
- If an argument is mutable, its value can be changed *from inside the function* via its corresponding parameter.


```python
outside = ['one', 'fine', 'day']
def mangle(arg):
    arg[1] = 'terrible!'
outside
mangle(outside)
outside
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "googlecode",
"highlightLines": true,
"highlightLanguage": "r",
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<!--Hat-tip: https://www.garrickadenbuie.com/blog/xaringan-tip-logo-all-slides/-->
<style>
.logo {
  background-image: url(img/logo-blue.png);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 66px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
