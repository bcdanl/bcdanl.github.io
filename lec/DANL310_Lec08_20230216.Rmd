---
title: "DANL 310 Lecture 8"
subtitle: "DANL 310: Data Visualization and Presentation"
author: "Byeong-Hak Choe"
institute: "SUNY Geneseo" 
date: "Febraury 16, 2023"
output:
  xaringan::moon_reader:
    css: 
      - default
      - css/nhsr.css
      - css/nhsr-fonts.css
    lib_dir: libs
    seal: false
    nature:
      highlightStyle: googlecode
      highlightLines: true
      highlightLanguage: ["r"]
      countIncrementalSlides: false
      ratio: "16:9"
    includes:
      after_body: [css/insert-logo.html]
---

```{r setup, include = FALSE}
library(knitr)
library(kableExtra)
library(tidyverse)
library(NHSRtheme)
library(fontawesome)
library(hrbrthemes)
library(ggrepel)

theme_set(theme_ipsum())
# set default options
opts_chunk$set(echo = T, eval = F,
               fig.width = 7.252,
               fig.height = 4,
               comment = "#",
               dpi = 300)

knitr::knit_engines$set("markdown")

xaringanExtra::use_tile_view()
xaringanExtra::use_panelset()
xaringanExtra::use_clipboard()
xaringanExtra::use_webcam()
xaringanExtra::use_broadcast()
xaringanExtra::use_share_again()
xaringanExtra::style_share_again(
  share_buttons = c("twitter", "linkedin", "pocket")
)


xaringanExtra::use_extra_styles(
  hover_code_line = TRUE,         #<<
  mute_unhighlighted_code = TRUE  #<<
)

# uncomment the following lines if you want to use the NHS-R theme colours by default
# scale_fill_continuous <- partial(scale_fill_nhs, discrete = FALSE)
# scale_fill_discrete <- partial(scale_fill_nhs, discrete = TRUE)
# scale_colour_continuous <- partial(scale_colour_nhs, discrete = FALSE)
# scale_colour_discrete <- partial(scale_colour_nhs, discrete = TRUE)
```

class: title-slide, left, bottom

# `r rmarkdown::metadata$title`
----
## **`r rmarkdown::metadata$subtitle`**
### `r rmarkdown::metadata$author`
### `r rmarkdown::metadata$date`


---
# Workflow
### <p style="color:#00449E"> Shortcuts for Presentation Slides </p>
 
- Use `o` to see the tile view of all the slide pages.

- Use `r fa("arrow-left")` and `r fa("arrow-right")` to turn over the slide pages.

- When you can't turn over slide pages, use **Ctrl + R** (**cmd + R** for mac users) to refresh the webpage.

---
class: inverse, center, middle

# Get Started with `ggplot` visualization
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---
# Get Started with `ggplot` visualization

*1*. Tell the `ggplot()` function what our **tidy** data is. 
  - `ggplot(data = ...)`


*2*. Tell `ggplot()` what relationships or distributions we want to see.
  - The `ggplot(mapping = aes(...))` 
  - `p <- ggplot(data = ... , aes(...))`
  
  
*3*. Tell `ggplot()` how we want to see the relationships in our data.
  - Choose a `geom_*()`.
  
  
*4*. Layer on `geoms` as needed, by adding them to the `p` object one at a time.


*5*. Use some additional functions to adjust scales, labels, tick marks, titles, etc.


---
class: inverse, center, middle

# Graph tables
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>



---
# Graph tables
### <p style="color:#00449E">  </p>

- We will learn about how to transform `data.frame` before we send it to `ggplot` to be turned into a figure. 
  - We will learn how to use some of `dplyr`'s “action verbs” to `filter`, `select`, `group`, `mutate`, `summarize` and transform our data.


- We will expand the number of geoms we know about, and learn more about how to choose between them. 
  - Different geoms potentially requires different aesthetic mappings.


- We will learn how to customize the scale, guide, and theme functions in ggplot.
  - These techniques will allow us to produce very sophisticated graphs in a systematic, comprehensible way.
  - [ggThemeAssist](https://github.com/calligross/ggthemeassist) can be helpful.
  
  

---
# Graph tables
### <p style="color:#00449E"> Use pipes to summarize data </p>
- Let's describe how the distribution of religious preferences varies by regions in the US using the `socviz::gss_sm` data.frame.

```{r, echo=FALSE, eval = T, warning = F, message= F, out.width = '100%', fig.align='center'}
knitr::include_graphics("../lec_figs/socviz_fig5_1.png")
```



---
# Graph tables
### <p style="color:#00449E"> Use pipes to summarize data </p>

- Group the data into the nested structure we want for our summary, such as “Religion by Region” or “Authors by Publications by Year”.


- Filter or select pieces of the data by row, column, or both. 


- Mutate the data by creating new variables at the current level of grouping.    - This adds new columns to the table without aggregating it.


- Summarize or aggregate the grouped data. 
  - This creates new variables (e.g., means with `mean()`, sums with `sum()`, and counts with `n()`) at a higher level of grouping.


---
# Graph tables
### <p style="color:#00449E"> Use pipes to summarize data </p>

- We use the dplyr functions, `group_by()`, `filter()`, `select()`, `mutate()`, and `summarize()`, to carry out these data transformation tasks within our pipeline (`%>%`, **Ctrl/Cmd + Shift + M**). 

- Let's create a new data.frame called `rel_by_region`.

```{r}
library(socviz)
rel_by_region <- gss_sm %>%
    group_by( bigregion, religion ) %>%
    summarize( N = n() ) %>%
    mutate( freq = N / sum(N),
            pct = round( (freq*100), 0) )

rel_by_region
```




---
# Graph tables
### <p style="color:#00449E"> Use pipes to summarize data </p>

- Now that we are working directly with percentage values in a summary table, we can use `geom_col()` instead of `geom_bar()`.

```{r, eval = T, echo = F, warning=F, message=F}
library(socviz)
rel_by_region <- gss_sm %>%
    group_by( bigregion, religion ) %>%
    summarize( N = n() ) %>%
    mutate( freq = N / sum(N),
            pct = round( (freq*100), 0) )
```

.pull-left[
```{r}
p <- ggplot( rel_by_region, 
             aes( x = bigregion, 
                  y = pct, 
                  fill = religion))

p + geom_col( position = "dodge2" ) +
    labs(x = "Region", 
         y = "Percent", 
         fill = "Religion") +
    theme(legend.position 
            = "top") 
```
]
.pull-right[
```{r, echo = F, eval = T}
p <- ggplot( rel_by_region, 
             aes( x = bigregion, 
                  y = pct, 
                  fill = religion))

p + geom_col( position = "dodge2" ) +
    labs(x = "Region", 
         y = "Percent", 
         fill = "Religion") +
    theme(legend.position 
            = "top") 
```
]



---
# Graph tables
### <p style="color:#00449E"> Use pipes to summarize data </p>

- Let's replicate the following bar chart:

```{r, echo = F, eval = T, message = F, warning = F, out.width='85%', fig.align='center'}
p <- ggplot(rel_by_region, aes(x = religion, y = pct, fill = religion))
p + geom_col(position = "dodge2") +
    labs(x = NULL, y = "Percent", fill = "Religion") +
    guides(fill = FALSE) + 
    coord_flip() + 
    facet_grid(~ bigregion)
```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let’s move to a new dataset, the `socviz::organdata` data.frame. 

```{r}
organdata
skimr::skim(organdata)
```

- We can take a look at a simple scatterplot of donors vs year.

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
p <- ggplot(data = organdata,
            mapping = aes(x = year, y = donors))
p + geom_point()
```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let's draw a yearly trend of `donors` for each country.

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
p <- ggplot(data = organdata,
            mapping = aes(x = year, y = donors))
p + geom_line(aes(group = country)) + facet_wrap(~ country)

```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let’s focus on the country-level variation of `donors` using `geom_boxplot()`, but without paying attention to the time trend.

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}

p <- ggplot(data = organdata,
            mapping = aes(y = country, x = donors))
p + geom_boxplot()
```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>


- We can reorder the levels using `fct_reorder(f, x, fun)`, which can take three arguments.

- `f`: the factor whose levels we want to modify.
- `x`: a numeric vector that we want to use to reorder the levels.
- Optionally, `fun`: a function that's used if there are multiple values of `x` for each value of `f`. The default value is *median*.


```{r}
organdata <- organdata %>%
  mutate(country = fct_reorder(country, tvhours, na.rm = T) ) 

p <- ggplot(data = organdata,
            mapping = aes(x = country, y = donors))
p + geom_boxplot() +
    labs(x = NULL) +
    coord_flip()

```




---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let’s replicate the following boxplot:

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
p <- ggplot(data = organdata,
            mapping = aes(x = reorder(country, donors, na.rm=TRUE),
                          y = donors, fill = world))
p + geom_boxplot() + labs(x=NULL) +
    coord_flip() + theme(legend.position = "top")

```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Sometimes it is better to sort the data with a categorical variable when plotting a bar chart or a Cleveland dotplot.



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let's summarize the data.frame `organdata` to calculate the mean and the standard deviation of each numeric variable for each `consent_law`-`country` pair.

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>%
    summarize(donors_mean= mean(donors, na.rm = TRUE),
              donors_sd = sd(donors, na.rm = TRUE),
              gdp_mean = mean(gdp, na.rm = TRUE),
              health_mean = mean(health, na.rm = TRUE),
              roads_mean = mean(roads, na.rm = TRUE),
              cerebvas_mean = mean(cerebvas, na.rm = TRUE))

by_country
```

- Would there be a simpler way to do the task above?



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- What we would like to do is apply the `mean()` and `sd()` functions to every numerical variable in `organdata`, but only the numerical ones. 

  - `summarize_if( is.numeric, lst(mean, sd), na.rm = T)` works really well.

```{r}
by_country <- organdata %>% group_by(consent_law, country) %>%
  summarize_if(is.numeric, list(mean = mean, 
                                median = median), 
               na.rm = TRUE) %>%
  ungroup()

```




---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let's draw the following dot plot.

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
by_country <- organdata %>% group_by(consent_law, country) %>%
  summarize_if(is.numeric, lst(mean, sd), na.rm = TRUE) %>%
  ungroup()

p <- ggplot(data = by_country,
            mapping = aes(x = donors_mean, y = reorder(country, donors_mean),
                          color = consent_law))
p + geom_point(size=3) +
    labs(x = "Donor Procurement Rate",
         y = "", color = "Consent Law") +
    theme(legend.position="top")

```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let's draw the following faceted dot plot.


```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
by_country <- organdata %>% group_by(consent_law, country) %>%
  summarize_if(is.numeric, lst(mean, sd), na.rm = TRUE) %>%
  ungroup()

p <- ggplot(data = by_country,
            mapping = aes(x = donors_mean,
                          y = reorder(country, donors_mean)))

p + geom_point(size=3) +
    facet_wrap(~ consent_law, scales = "free_y", ncol = 1) +
    labs(x= "Donor Procurement Rate",
         y= "") 
```



---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Cleveland dotplots are generally preferred to bar or column charts.
  - When making them, put the categories on the y-axis and order them in the way that is most relevant to the numerical summary you are providing.
  - This sort of plot is also an excellent way to summarize model results or any data with **error ranges**. 
  
  
- Using `geom_pointrange()`, we can tell ggplot to show us a point estimate and a range around it.
  -  With `geom_pointrange()`, we map our `x` and `y` variables as usual, but the function needs a little more information than `geom_point()`, for example (`ymin`, `ymax`) or (`xmin`, `xmax`). 
  
  

---
# Graph tables
### <p style="color:#00449E"> Continuous variables by group or category </p>

- Let's draw the following dot-and-whisker plot.

```{r, echo = F, eval = T, warning = F, message= F, out.width='85%', fig.align='center'}
p <- ggplot(data = by_country, mapping = aes(x = reorder(country,
              donors_mean), y = donors_mean))

p + geom_pointrange(mapping = aes(ymin = donors_mean - donors_sd,
       ymax = donors_mean + donors_sd)) +
     labs(x= "", y= "Donor Procurement Rate") + coord_flip()
```



---
class: inverse, center, middle

# Understanding Scales, Guides, and Themes
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---
# Understanding Scales, Guides, and Themes
### <p style="color:#00449E">  </p>

- We have used `scale_x_log10()`, `scale_x_continuous()` and other` scale_*_*()` functions to adjust axis labels. 

- We used the `guides()` function to remove the legends for a color mapping and a `label` mapping. 

- We also used the `theme()` function to move the position of a legend from the side to the top of a figure.

- What are the differences between the `scale_*_*()` functions, the `guides()` function, and the `theme()` function? 

- When do we know to use one rather than the other? 

- Why are there so many `scale_*_*()` functions? 

- How can we tell which one we need?


---
# Understanding Scales, Guides, and Themes
### <p style="color:#00449E">  </p>


- Here is a rough and ready starting point:

.panelset[
.panel[.panel-name[scale]

- Every aesthetic mapping has a scale. 

  - If we want to adjust how that scale is marked or graduated, then we use a `scale_*_*()` function.

]

.panel[.panel-name[guides]
- Many scales come with a *legend* or key to help the reader interpret the graph. These are called `guides`. 

  - We can make adjustments to them with the `guides()` function. 

  - Perhaps the most common use case is to make the legend disappear.

  - Another is to adjust the arrangement of the key in *legends* and *colorbars*.
  
  - `guides` is also one of the parameters in `scales_*_*()`.

]

.panel[.panel-name[theme]
- Graphs have other features not strictly connected to the logical structure of the data being displayed. 

  - These include things like their background color, the typeface used for labels, or the placement of the legend on the graph. 
  
  - To adjust these, use the `theme()` function.


]

]





---
# Understanding Scales, Guides, and Themes
### <p style="color:#00449E">  </p>
  
- `scale_*_*()` and `guides()` are closely connected.
  - The `guides()` provides information about the `scale`, such as in a **legend** or **colorbar**.
  - So, it is possible to make adjustments to guides from inside the various `scale_*_*()` functions.

```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads, y = donors, color = world))
p + geom_point()
```
- The `x` and `y` scales are both **continuous**.
- The `color` scale is **discrete**.
  - A `color` or `fill` mapping can also be a *continuous* quantity (*colorbar*).
  
  
  
---
# Understanding Scales, Guides, and Themes
### <p style="color:#00449E"> `scale_<MAPPING>_<KIND>` </p>

- Because we have several potential mappings, and each mapping might be to one of several different scales, we end up with a lot of individual `scale_*_*` functions. 
  - Each deals with one combination of mapping and scale. Too many to memorize. 
  - They are named according to a consistent logic:
  
```{r, echo=FALSE, eval = T, warning = F, message= F,  out.width = '50%', fig.align='center'}
knitr::include_graphics("../lec_figs/scale_mapping_kind.png")
```
 
- [https://ggplot2tor.com/scales](https://ggplot2tor.com/scales) provides a complete guide to scales.
  - This app makes it easy for you to find the right scales and arguments for your variable types and aesthetics.



---
# Understanding Scales, Guides, and Themes
### <p style="color:#00449E">  </p>

.panelset[
.panel[.panel-name[(1)]
- Let's replicate the following:
  <!-- - Use the `log10` scale on x-axis. -->
  <!-- - Break y-axis at `c(5, 15, 25)`, and label them as `c("Five", "Fifteen", "Twenty Five")`. -->

```{r, echo = F, eval = T, warning = F, message= F, out.width='75%'}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_y_continuous(breaks = c(5, 15, 25),
                       labels = c("Five", "Fifteen", "Twenty Five"))

```

]


.panel[.panel-name[(2)]
- Let's replicate the following:
  <!-- - Label colors to `c("Corporatist", "Liberal", "Social Democratic", "Unclassified")` -->
  <!-- - Label `x`-axis, `y`-axis, and a title of `color` legend using `labs()`. -->

```{r, echo = F, eval = T, warning = F, message= F, out.width='75%'}
p <- ggplot(data = organdata,
            mapping = aes(x = roads,
                          y = donors,
                          color = world))
p + geom_point() +
    scale_color_discrete(labels =
                             c("Corporatist", "Liberal",
                               "Social Democratic", "Unclassified")) +
    labs(x = "Road Deaths",
         y = "Donor Procurement",
        color = "Welfare State")
```

]


]

---
class: inverse, center, middle

# Add Labels and Make Notes
<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>

---
# Add Labels and Make Notes
### <p style="color:#00449E"> Plot text directly </p>

- It can sometimes be useful to plot the labels along with the points in a scatterplot, or just plot informative labels directly.
  - We can do this with `geom_text()`.
  
```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = roads_mean, y = donors_mean))
p + geom_point() + geom_text(mapping = aes(label = country))
```

- By default, the text is plotted right on top of the points.
- Setting `hjust = 0` will left justify the label, and `hjust = 1` will right justify it.

```{r}
p + geom_point() + geom_text(mapping = aes(label = country), hjust = 0)
```





---
# Add Labels and Make Notes
### <p style="color:#00449E">  </p>

```{r, echo = F, eval = T, warning = F, message = F, out.width = '100%', fig.align = 'center'}
p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

p <- ggplot(elections_historic, aes(x = popular_pct, y = ec_pct,
                                    label = winner_label))

p + geom_hline(yintercept = 0.5, linewidth = 1.4, color = "gray80") +
    geom_vline(xintercept = 0.5, linewidth = 1.4, color = "gray80") +
    geom_point() +
    geom_text_repel() +
    scale_x_continuous(labels = scales::percent) +
    scale_y_continuous(labels = scales::percent) +
    labs(x = x_label, y = y_label, title = p_title, subtitle = p_subtitle,
         caption = p_caption)

```



---
# Add Labels and Make Notes
### <p style="color:#00449E"> Plot text directly </p>

- Instead of wrestling any further with `geom_text()`, we can use `ggrepel::geom_text_repel()` instead. 

```{r}
install.packages("ggrepel")
library(ggrepel)
```

- Let's use some historical U.S. presidential election data provided in the `socviz` library.
```{r}
socviz::elections_historic %>% select(2:7) 
```

---
# Add Labels and Make Notes
### <p style="color:#00449E"> Plot text directly </p>

.panelset[
.panel[.panel-name[Step 1]
- Let's map aethetics to variables
```{r}
p <- ggplot(elections_historic, aes(x = popular_pct, y = ec_pct,
                                    label = winner_label))
```

]

.panel[.panel-name[Step 2]
- Then, add geometric objects to ggplot.
```{r}
p <- p + 
    geom_hline(yintercept = 0.5, linewidth = 1.4, color = "gray80") +
    geom_vline(xintercept = 0.5, linewidth = 1.4, color = "gray80") +
    geom_point() +
    geom_text_repel()
p
```
- We use two new geoms, `geom_hline(yintercept = NUMBER)` and `geom_vline(xintercept = NUMBER)` to make the lines.
]



.panel[.panel-name[Step 3]
- Let's set the scales for `x` and `y`.
```{r}
p <- p + 
     scale_x_continuous(labels = scales::percent) +
     scale_y_continuous(labels = scales::percent) 
p
```

]


.panel[.panel-name[Step 4]
- Let's set the labels.
```{r}
p_title <- "Presidential Elections: Popular & Electoral College Margins"
p_subtitle <- "1824-2016"
p_caption <- "Data for 2016 are provisional."
x_label <- "Winner's share of Popular Vote"
y_label <- "Winner's share of Electoral College Votes"

p + labs(x = x_label, y = y_label, 
         title = p_title, subtitle = p_subtitle,
         caption = p_caption)
```

]


]


---
# Add Labels and Make Notes
### <p style="color:#00449E"> Label Outliers </p>

- Sometimes we want to pick out some points of interest in the data without labeling every single item. 
  -  We do this using the `filter()` function.

.panelset[
.panel[.panel-name[(1)]
```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = gdp_mean, y = health_mean))

p + geom_point() +
    geom_text_repel(data = subset(by_country, gdp_mean > 25000),
                    mapping = aes(label = country))
```
]

.panel[.panel-name[(2)]
```{r}
p <- ggplot(data = by_country,
            mapping = aes(x = gdp_mean, y = health_mean))
p + geom_point() +
    geom_text_repel(data = filter(by_country,
                                  gdp_mean > 25000 | health_mean < 1500 |
                                  country %in% "Belgium"),
                    mapping = aes(label = country))
```
]



]



---
# Add Labels and Make Notes
### <p style="color:#00449E"> Label Outliers </p>

- We can also add a logical variable (either `TRUE` or `FALSE`) to label specific points using `filter()`.

```{r}
# creating a dummy variable in the data set for labels
organdata$ind <- organdata$ccode %in% c("Ita", "Spa") & organdata$year > 1998   

p <- ggplot(data = organdata,
            mapping = aes(x = roads, y = donors, 
                          color = ind))
p + geom_point() +
    geom_text_repel(data = filter(organdata, ind),
                    mapping = aes(label = ccode)) +
    guides(label = "none", color = "none")
```


---
# Add Labels and Make Notes
### <p style="color:#00449E"> Write and draw in the plot area </p>

- We can use `annotate()` to annotate the figure directly. 
  <!-- - Maybe we sometimes need to point out something important that is not mapped to a variable.  -->

.panelset[
.panel[.panel-name[text]
```{r}
p <- ggplot(data = organdata, mapping = aes(x = roads, y = donors))
p + geom_point() + annotate(geom = "text", x = 91, y = 33,
                            label = "A surprisingly high \n recovery rate.",
                            hjust = 0)
```
]

.panel[.panel-name[rect]
```{r}
p <- ggplot(data = organdata,
            mapping = aes(x = roads, y = donors))
p + geom_point() +
    annotate(geom = "rect", xmin = 125, xmax = 155,
             ymin = 30, ymax = 35, fill = "red", alpha = 0.2) + 
    annotate(geom = "text", x = 157, y = 33,
             label = "A surprisingly high \n recovery rate.", hjust = 0)

```

]

.panel[.panel-name[point]
```{r}
p <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(
    data = filter(mpg, manufacturer == "subaru"), color = "orange", size = 3) +
  geom_point() 

p + 
  annotate(geom = "point", x = 5.5, y = 40, colour = "orange", size = 3) + 
  annotate(geom = "point", x = 5.5, y = 40) + 
  annotate(geom = "text", x = 5.6, y = 40, label = "subaru", hjust = "left")
```

]

.panel[.panel-name[curve]
```{r}
p + 
  annotate(
    geom = "curve", x = 4, y = 35, xend = 2.65, yend = 27, 
    curvature = .3, arrow = arrow(length = unit(2, "mm"))
  ) +
  annotate(geom = "text", x = 4.1, y = 35, label = "subaru", hjust = "left")
```

]
]

